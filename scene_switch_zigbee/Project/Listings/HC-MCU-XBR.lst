C51 COMPILER V9.52.0.0   HC_MCU_XBR                                                        01/18/2021 13:48:15 PAGE 1   


C51 COMPILER V9.52.0.0, COMPILATION OF MODULE HC_MCU_XBR
OBJECT MODULE PLACED IN .\Objects\HC-MCU-XBR.obj
COMPILER INVOKED BY: d:\cccc2020\TOOL\Keil\C51\BIN\C51.EXE ..\User\HC-MCU-XBR.c OPTIMIZE(9,SIZE) BROWSE DEBUG OBJECTEXTE
                    -ND PRINT(.\Listings\HC-MCU-XBR.lst) TABS(2) OBJECT(.\Objects\HC-MCU-XBR.obj)

line level    source

   1          #define ALLOCATE_EXTERN
   2          #include "HC89S003F4.h"
   3          //#include "Mcu_api.h"
   4          #include "zigbee.h"
   5          
   6          #define V12 //Ó²¼ş°å¿¨µÄ°æ±¾
   7          //#define V10
   8          
   9          //#define  VERSION  0X21
  10          
  11          #define TH_LOW 30000
  12          #define TH_HIGH 4000000
  13          
  14          #define TH_DEF 40000
  15          
  16          //ÔÊĞíÔëÉùÖµÆ«²î·¶Î§
  17          #define MAX_DELTA0 20000 //×î´óÆ«²îµÍÖµ
  18          #define MAX_DELTA1 60000 //×î´óÆ«²î¸ßÖµ
  19          
  20          #define MAX_DELAY 1800
  21          //×î´óÑÓÊ±ÃëÊı
  22          
  23          //¸Ğ¹âÃÅÏŞ-30¶ÔÓ¦8LUX×óÓÒµÄADÖµ,ÉèÖÃÎª255±íÊ¾²»¼ì²â¸Ğ¹â
  24          #define LIGHT_TH0 255
  25          //30
  26          
  27          //Ò»¸ö¼ì²âÖÜÆÚÎª0.25Ãë
  28          //#define DELAY_NUM 20
  29          
  30          //#define LIGHT_ON P0_6=0
  31          //#define LIGHT_OFF P0_6=1
  32          
  33          //void Delay_2us(u16 Cnt);    //ÑÓÊ±º¯Êı
  34          
  35          // bit Timer1_FLAG;
  36          // bit Time_10mS_FLAG;
  37          // bit Time_100mS_FLAG;
  38          // bit Time_200mS_FLAG;
  39          // bit Time_500mS_FLAG;
  40          // bit Time_1S_FLAG;
  41          // bit Time_10S_FLAG;
  42          // bit Time_1Min_FLAG;
  43          // bit Time_1H_FLAG;
  44          
  45          volatile ulong Timer_Counter = 0;
  46          
  47          //u8 Uart1_RX_Buff[10] = {0};          //ÓÃÓÚ´æ·ÅUART1½ÓÊÕÊı¾İ
  48          //u8 Uart1_RX_Cnt = 0;                 //UART1½ÓÊÕ¼ÆÊı
  49          //u8 Uart1_TX_Buff[20] = {0};          //ÓÃÓÚ´æ·ÅUART1·¢ËÍÊı¾İ
  50          //u8 Uart1_TX_Cnt = 0;                 //UART1·¢ËÍ¼ÆÊı
  51          
  52          // u16 AN1_Data = 0;
  53          // u16 AN7_Data = 0;
  54          // u8 Uart_Cnt = 0;
C51 COMPILER V9.52.0.0   HC_MCU_XBR                                                        01/18/2021 13:48:15 PAGE 2   

  55          
  56          u8 xdata SUM1_counter = 0; //???
  57          u8 xdata SUM0_num = 12;    //???
  58          u8 xdata SUM1_num = 64;    //???
  59          ulong xdata SUM01;
  60          ulong xdata SUM10 = 0;     //SUM1ÖµµÄ¼¸´ÎÆ½¾ùÖµ£¬Ê±¼äÉÏµÄÖÍºóÖµ
  61          ulong xdata SUM0 = 0;    //
  62          ulong xdata SUM1 = 0;    //Æ½¾ù¾ø¶ÔÀë²îµÄÀÛ¼ÓºÏµÄË²Ê±Öµ
  63          ulong xdata ALL_SUM1 = 0;  //SUM1µÄÀÛ¼ÓÖµ
  64          ulong xdata SUM16 = 0;     //2^16´ÎµÄÀÛ¼ÆÖµ±äÁ¿
  65          ulong xdata SUM = 0;     //an1µÄrawÀÛ¼ÓÖµ
  66          u16 xdata start_times = 1; //???
  67          u16 xdata times = 0;     //Ö÷Ñ­»·´ÎÊı
  68          ulong xdata TH;        //ÉèÖÃÎó²îãĞÖµ£¬¿ÉÓÉAPPÉèÖÃµÄ¸ĞÓ¦Ç¿¶È×ª»»
  69          ulong xdata MAX_DELTA; //×î´óÆ«²îÖµ
  70          u8 xdata alarm_times = 0;
  71          u8 xdata stop_times = 0; //???
  72          
  73          uint xdata LIGHT = 0;   //°éÁÁµÆÃëµÄ¼ÆÊıÆ÷
  74          uint xdata LIGHT_off = 0; //ÎŞÈËÃğµÆµÄ·ÖÖÓ¼ÆÊıÆ÷
  75          uint xdata average;     //an1µÄrawÆ½¾ùÖµ
  76          
  77          u8 xdata light_ad;  //¹âÃôÊµÊ±Öµraw
  78          u8 xdata light_ad0; //¹âÃô³õÊ¼Ë²Ê±Öµraw
  79          
  80          u8 xdata check_sum, send_byte;
  81          u8 xdata check_light_times = 8;  //ÓÃÓÚ¹âÃô¼ì²éµÄ¼ÆÊıÆ÷
  82          u8 xdata calc_average_times = 0; //ÓÃÓÚ¼ÆËãÆ½¾ùÖµµÄ¼ÆÊıÆ÷
  83          u8 xdata LIGHT_TH;
  84          u16 xdata DELAY_NUM;
  85          u8 xdata lowlightDELAY_NUM;
  86          u8 xdata RXnum = 0;
  87          u8 xdata while_1flag = 0;     //°éÁÁÍê³É±êÖ¾
  88          u8 xdata while_2flag = 0;     //???
  89          u8 xdata SWITCHflag = 0;  //ÔİÊ±Ã»ÓĞÊ¹ÓÃ
  90          u8 xdata SWITCHflag2 = 0; //µÆ¿ª¹ØµÄ±äÁ¿£¬¿ÉÓÉAPPÉèÖÃ
  91          u8 xdata SWITCHfXBR = 1;  //À×´ï¸ĞÓ¦¿ª¹ØµÄ±äÁ¿£¬¿ÉÓÉAPPÉèÖÃ
  92          u8 xdata lightvalue = 10; //ÁÁ¶ÈÖµ£¬¿ÉÓÉAPPÉèÖÃ
  93          u8 xdata switchcnt = 0;
  94          u8 xdata slowchcnt = 10;          //ÁÁ¶È½¥Á¿Öµ
  95          u8 xdata resetbtcnt = 0;          //ÎªÖØÖÃÀ¶ÑÀÄ£¿éÉèÖÃµÄ¼ÆÊıÆ÷
  96          u8 xdata XRBoffbrightvalue = 0;       //µ±¹Ø±ÕÀ×´ïÊ±£¬APPÉèÖÃµÄÁÁ¶ÈÖµ
  97          volatile u16 xdata lowlight1mincount = 0; //timerµÄ¼ÆÊıÆ÷1ms×Ô¼Ó
  98          volatile u8 xdata lowlight1minflag = 0;   //timerµÄ·ÖÖÓ±êÖ¾
  99          volatile u16 xdata light1scount = 0;    //timerµÄ¼ÆÊıÆ÷1ms×Ô¼Ó
 100          volatile u16 xdata light1sflag = 0;     //timerµÄÃë±êÖ¾
 101          
 102          u8 xdata Linkage_flag = 0;
 103          u8 xdata Light_on_flag = 0;
 104          u8 xdata Light_on_flagpre = 0;
 105          
 106          u8 xdata zigbee_join_cnt = 0;
 107          u8 xdata all_day_micro_light_enable = 0;
 108          
 109          u16 xdata radar_trig_times = 0;
 110          u16 xdata radar_trig_times_last = 0;
 111          
 112          u8 xdata light_status_xxx = 0;
 113          u8 xdata light_status_xxx_last = 0;
 114          
 115          u16 xdata radar_number_count = 0;
 116          u8 xdata radar_number_send_flag = 0;
C51 COMPILER V9.52.0.0   HC_MCU_XBR                                                        01/18/2021 13:48:15 PAGE 3   

 117          u8 xdata radar_number_send_flag2 = 0;
 118          
 119          u8 xdata person_in_range_flag = 0;
 120          u8 xdata person_in_range_flag_last = 0;
 121          
 122          unsigned char PWM3init(unsigned char ab);
 123          void Flash_EraseBlock(unsigned int fui_Address); //ÉÈÇø²Á³ı
 124          void FLASH_WriteData(unsigned char fuc_SaveData, unsigned int fui_Address);
 125          void Flash_WriteArr(unsigned int fui_Address,unsigned char fuc_Length,unsigned char *fucp_SaveArr);//Ğ´ÈëÈ
             -ÎÒâ³¤¶ÈÊı¾İ
 126          void Flash_ReadArr(unsigned int fui_Address, unsigned char fuc_Length, unsigned char *fucp_SaveArr); //¶ÁÈ
             -¡ÈÎÒâ³¤¶ÈÊı¾İ
 127          void savevar(void);
 128          
 129          unsigned char idata guc_Read_a[12] = {0x00}; //ÓÃÓÚ´æ·Å¶ÁÈ¡µÄÊı¾İ
 130          unsigned char xdata guc_Read_a1[2] = {0x00}; //ÓÃÓÚ´æ·Å¶ÁÈ¡µÄÊı¾İ
 131          
 132          #pragma disable
 133          void Flash_WriteArr(unsigned int fui_Address,unsigned char fuc_Length,unsigned char *fucp_SaveArr)
 134          {
 135   1        unsigned char fui_i = 0;
 136   1        EA=0;
 137   1        for(fui_i=0;fui_i<fuc_Length;fui_i++)
 138   1        {
 139   2          FLASH_WriteData(*(fucp_SaveArr++), fui_Address++); 
 140   2        }
 141   1        EA=1;
 142   1      }
 143          
 144          void Flash_ReadArr(unsigned int fui_Address, unsigned char fuc_Length, unsigned char *fucp_SaveArr)
 145          {
 146   1        while (fuc_Length--)
 147   1          *(fucp_SaveArr++) = *((unsigned char code *)(fui_Address++)); //¶ÁÈ¡Êı¾İ
 148   1      }
 149          
 150          void Delay_us(uint q)
 151          {
 152   1        uint j;
 153   1        for (j = 0; j < q; j++)
 154   1        {
 155   2          ;
 156   2        }
 157   1      }
 158          
 159          void Delay_ms(uint t)
 160          {
 161   1        Timer_Counter = 0;
 162   1        while (Timer_Counter < t)
 163   1        {
 164   2          WDTC |= 0x10; //Çå¿´ÃÅ¹·
 165   2        }
 166   1      }
 167          
 168          void Delay_us_1(uint q1)
 169          {
 170   1        uint j;
 171   1        for (j = 0; j < q1; j++)
 172   1        {
 173   2          ;
 174   2        }
 175   1      }
 176          
C51 COMPILER V9.52.0.0   HC_MCU_XBR                                                        01/18/2021 13:48:15 PAGE 4   

 177          // void Delay_ms(uint t)
 178          // {
 179          //  for(;t>0;t--)
 180          //  {
 181          //    Delay_us_1(1000);
 182          //    WDTC |= 0x10;   //Çå¿´ÃÅ¹·
 183          //  }
 184          // }
 185          
 186          /***************************************************************************************
 187            * @ËµÃ÷   ÏµÍ³³õÊ¼»¯º¯Êı
 188            * @²ÎÊı   ÎŞ
 189            * @·µ»ØÖµ ÎŞ
 190            * @×¢     ÎŞ
 191          ***************************************************************************************/
 192          void InitSYS()
 193          {
 194   1        /********************************ÏµÍ³ÆµÂÊ³õÊ¼»¯***************************************/
 195   1      
 196   1        CLKSWR = 0x51;   //Ñ¡ÔñÄÚ²¿¸ßÆµRCÎªÏµÍ³Ê±ÖÓ£¬ÄÚ²¿¸ßÆµRC 2·ÖÆµ£¬Fosc=16MHz
 197   1        CLKDIV = 0x01;   //Fosc 1·ÖÆµµÃµ½Fcpu£¬Fcpu=16MHz
 198   1        FREQ_CLK = 0x10; //IAPÆµÂÊ
 199   1      
 200   1        /**********************************µÍÑ¹¸´Î»³õÊ¼»¯**************************************/
 201   1      
 202   1        //  BORC = 0xC0;                       //Ê¹ÄÜµÍÑ¹¸´Î»1.8V£¬´øÏû¶¶Ê¹ÄÜ
 203   1        //  BORDBC = 0x01;                     //Ïû¶¶Ê±¼äBORDBC*8TCPU+2TCPU
 204   1      
 205   1        /***********************************¿´ÃÅ¿Ú³õÊ¼»¯***************************************/
 206   1        WDTC = 0x5F;   //ÔÊĞíWDT¸´Î»£¬¿ÕÏĞÄ£Ê½ÏÂ½ûÖ¹WDT£¬Ñ¡Ôñ1024·ÖÆµ£¨ÄÚ²¿µÍÆµÊ±ÖÓ44K£©
 207   1        WDTCCR = 0X20; //0X20/44  =0.73Ãë           //0xFF;  //Òç³öÊ±¼äÔ¼6Ãë
 208   1                 //Òç³ö¼ÆËãÊ±¼ä=£¨WDT·ÖÆµÏµÊı*£¨WDTCCR+1£©£©/ÄÚ²¿µÍÆµRCÆµÂÊ
 209   1      }
 210          
 211          /***************************************************************************************
 212            * @ËµÃ÷   ¶¨Ê±Æ÷³õÊ¼»¯º¯Êı
 213            * @²ÎÊı   ÎŞ
 214            * @·µ»ØÖµ ÎŞ
 215            * @×¢     ÎŞ
 216          ***************************************************************************************/
 217          void Timer_Init()
 218          {
 219   1        /**********************************TIM1ÅäÖÃ³õÊ¼»¯**************************************/
 220   1        TCON1 = 0x00; //T1¶¨Ê±Æ÷Ê±ÖÓÎªFosc
 221   1        TMOD = 0x01;  //T1-16Î»ÖØ×°ÔØ¶¨Ê±Æ÷/¼ÆÊıÆ÷,T0-16Î»¶¨Ê±Æ÷
 222   1      
 223   1        //Tim1¼ÆËãÊ±¼ä  = (65536 - 0xFACB) * (1 / (Fosc /Timer·ÖÆµÏµÊı))
 224   1        //        = 1333 / (16000000 / 12)
 225   1        //        = 1 ms
 226   1      
 227   1        //T1¶¨Ê±1ms
 228   1        //·´ÍÆ³õÖµ  = 65536 - ((1/1000) / (1/(Fosc / Timer·ÖÆµÏµÊı)))
 229   1        //        = 65536 - ((1/1000) / (1/(16000000 / 12)))
 230   1        //      = 65536 - 1333
 231   1        //      = 0xFACB
 232   1      
 233   1        TH1 = 0xFA;
 234   1        TL1 = 0xCB;   //T1¶¨Ê±1ms
 235   1        IE |= 0x08;   //´ò¿ªT1ÖĞ¶Ï
 236   1        TCON |= 0x40; //Ê¹ÄÜT1
 237   1      
 238   1        TH0 = 0xCB;
C51 COMPILER V9.52.0.0   HC_MCU_XBR                                                        01/18/2021 13:48:15 PAGE 5   

 239   1        TL0 = 0xEB; //T0¶¨Ê±Ê±¼ä10ms
 240   1      
 241   1        TCON |= 0x10; //Ê¹ÄÜT0
 242   1      }
 243          
 244          /***************************************************************************************
 245            * @ËµÃ÷   UART1³õÊ¼»¯º¯Êı
 246            * @²ÎÊı   ÎŞ
 247            * @·µ»ØÖµ ÎŞ
 248            * @×¢     ÎŞ
 249          ***************************************************************************************/
 250          void UART1_Init()
 251          {
 252   1        /**********************************UARTÅäÖÃ³õÊ¼»¯**************************************/
 253   1        P2M0 = P2M0 & 0xF0 | 0x08; //P20ÉèÖÃÎªÍÆÍìÊä³ö
 254   1        P0M2 = P0M2 & 0xF0 | 0x02; //P04ÉèÖÃÎªÉÏÀ­ÊäÈë
 255   1        P0_4 = 1;
 256   1        TXD_MAP = 0x20; //TXDÓ³ÉäP20
 257   1        RXD_MAP = 0x04; //RXDÓ³ÉäP04
 258   1        T4CON = 0x06; //T4¹¤×÷Ä£Ê½£ºUART1²¨ÌØÂÊ·¢ÉúÆ÷
 259   1      
 260   1        //²¨ÌØÂÊ¼ÆËã
 261   1        //²¨ÌØÂÊ = 1/16 * (T4Ê±ÖÓÔ´ÆµÂÊ / ¶¨Ê±Æ÷4Ô¤·ÖÆµ±È) / (65536 - 0xFF98)
 262   1        //       = 1/16 * ((16000000 / 1) / 104)
 263   1        //     = 9615.38(Îó²î0.16%)
 264   1      
 265   1        //²¨ÌØÂÊ9600
 266   1        //·´ÍÆ³õÖµ = (65536 - ((T4Ê±ÖÓÔ´ÆµÂÊ / ¶¨Ê±Æ÷4Ô¤·ÖÆµ±È) * (1 / 16)) / ²¨ÌØÂÊ)
 267   1        //       = (65536 - (16000000 * (1 / 16) / 9600))
 268   1        //       = (65536 - 104.167)
 269   1        //         = FF98
 270   1        //0xFF98->9600
 271   1        //0xFFCC->19200
 272   1        //0xFFEF->57600
 273   1      
 274   1        TH4 = 0xFF;
 275   1        TL4 = 0x98;   //²¨ÌØÂÊ9600    //0xEE;       //²¨ÌØÂÊ56000
 276   1        SCON2 = 0x02; //8Î»UART£¬²¨ÌØÂÊ¿É±ä
 277   1        SCON = 0x10;  //ÔÊĞí´®ĞĞ½ÓÊÕ
 278   1        IE |= 0X10;   //Ê¹ÄÜ´®¿ÚÖĞ¶Ï
 279   1                //EA = 1;                              //Ê¹ÄÜ×ÜÖĞ¶Ï
 280   1      }
 281          
 282          /***************************************************************************************
 283            * @ËµÃ÷   ADC³õÊ¼»¯º¯Êı
 284            * @²ÎÊı   ÎŞ
 285            * @·µ»ØÖµ ÎŞ
 286            * @×¢     ÎŞ
 287          ***************************************************************************************/
 288          void ADC_Init()
 289          {
 290   1      
 291   1        ADCC0 |= 0x03; //²Î¿¼Ô´ÎªÄÚ²¿2V
 292   1        ADCC0 |= 0x80; //´ò¿ªADC×ª»»µçÔ´
 293   1        Delay_us(20);  //ÑÓÊ±20us£¬È·±£ADCÏµÍ³ÎÈ¶¨
 294   1        ADCC1 = 0x01;  //Ñ¡ÔñÍâ²¿Í¨µÀ1
 295   1        ADCC2 = 0x4B;  //8·ÖÆµ    //×ª»»½á¹û12Î»Êı¾İ£¬Êı¾İÓÒ¶ÔÆë£¬ADCÊ±ÖÓ16·ÖÆµ-1MHZ//0X4B-8·ÖÆµ//0X49-4·ÖÆµ
 296   1      }
 297          
 298          /***************************************************************************************
 299            * @ËµÃ÷   IO¿Ú³õÊ¼»¯º¯Êı
 300            * @²ÎÊı   ÎŞ
C51 COMPILER V9.52.0.0   HC_MCU_XBR                                                        01/18/2021 13:48:15 PAGE 6   

 301            * @·µ»ØÖµ ÎŞ
 302            * @×¢     ÎŞ
 303          ***************************************************************************************/
 304          void GPIO_Init()
 305          {
 306   1        //P0M0·Ö¸ß4Î»ÓëµÍ4Î»£¬µÍ4Î»¿ØÖÆP00ÊäÈëÊä³ö£¬¸ß4Î»¿ØÖÆP01ÊäÈëÊä³ö£¬ÆäËûÒÔ´ËÀàÍÆ
 307   1        //P0M1¸ß4¿ØÖÆP03£¬µÍ4¿ØÖÆP02
 308   1        //P1M2¸ß4¿ØÖÆP15£¬µÍ4¿ØÖÆP14
 309   1      
 310   1        //  P0M0 = P0M0&0xF0|0x08;          //P00ÉèÖÃÎªÍÆÍìÊä³ö
 311   1        //  P0M0 = P0M0&0x0F|0x30;          //P01ÉèÖÃÎªÄ£ÄâÊäÈë
 312   1        //  P0M3 = P0M3&0x0F|0x30;          //P07ÉèÖÃÎªÄ£ÄâÊäÈë
 313   1        //  P0M3 = P0M3&0xF0|0x08;          //P06ÉèÖÃÎªÍÆÍìÊä³ö
 314   1      
 315   1      #ifdef V11
              
                P0M0 = P0M0 & 0xF0 | 0x08; //P00ÉèÖÃÎªÍÆÍìÊä³ö
              
                P0M0 = P0M0 & 0x0F | 0x30; //P01ÉèÖÃÎªÄ£ÄâÊäÈë
                //P0M3 = P0M3&0x0F|0x30;          //P07ÉèÖÃÎªÄ£ÄâÊäÈë
                //  P0M0 = P0M0&0x0F|0x80;          //P01ÉèÖÃÎªÍÆÍìÊä³ö
              
                P0M2 = P0M2 & 0x0F | 0x80; //P05ÉèÖÃÎªÍÆÍìÊä³ö
              
                P0M3 = P0M3 & 0xF0 | 0x03; //P06ÉèÖÃÎªÄ£ÄâÊäÈë  //|0x08;          //P06ÉèÖÃÎªÍÆÍìÊä³ö
              
                P0M3 = P0M3 & 0x0F | 0x20; //P07ÉèÖÃÎªÉÏÀ­ÊäÈë
              
              #endif
 330   1      
 331   1      #ifdef V10
              
                P0M0 = P0M0 & 0xF0 | 0x08; //P00
              
                P0M0 = P0M0 & 0x0F | 0x30; //P01
                P0M3 = P0M3 & 0x0F | 0x30; //P07
                               // P0M0 = P0M0&0x0F|0x80;          //P01
              
                P0M3 = P0M3 & 0xF0 | 0x08; //P06
              
              #endif
 342   1      
 343   1      #ifdef V12
 344   1      
 345   1        P1M0 = P1M0 & 0xF0 | 0x08; //P10ÉèÖÃÎªÍÆÍìÊä³ö
 346   1      
 347   1        P0M0 = P0M0 & 0x0F | 0x30; //P01ÉèÖÃÎªÄ£ÄâÊäÈë
 348   1      
 349   1        P2M1 = P2M1 & 0xF0 | 0x03; //P22ÉèÖÃÎªÄ£ÄâÊäÈë
 350   1      
 351   1        //P0M3 = P0M3&0x0F|0x30;          //P07ÉèÖÃÎªÄ£ÄâÊäÈë
 352   1        //  P0M0 = P0M0&0x0F|0x80;          //P01ÉèÖÃÎªÍÆÍìÊä³ö
 353   1      
 354   1        //P0M2 = P0M2&0x0F|0x80;          //P05ÉèÖÃÎªÍÆÍìÊä³ö
 355   1      
 356   1        //P0M3 = P0M3&0xF0|0x03;      //P06ÉèÖÃÎªÄ£ÄâÊäÈë  //|0x08;         //P06ÉèÖÃÎªÍÆÍìÊä³ö
 357   1      
 358   1        //  P0M3 = P0M3&0x0F|0x20;          //P07ÉèÖÃÎªÉÏÀ­ÊäÈë
 359   1      
 360   1      #endif
 361   1      }
 362          
C51 COMPILER V9.52.0.0   HC_MCU_XBR                                                        01/18/2021 13:48:15 PAGE 7   

 363          // u16 Read_ADC(u8 Channel)
 364          // {
 365          //  u16 ADC_Temp;
 366          //  ADCC1 = Channel;              //Ñ¡ÔñÍâ²¿Í¨µÀ1
 367          //   ADCC0 |= 0x40;         //Æô¶¯ADC×ª»»
 368          //  while(!(ADCC0&0x20));   //µÈ´ıADC×ª»»½áÊø
 369          //  ADCC0 &=~ 0x20;         //Çå³ı±êÖ¾Î»
 370          //  ADC_Temp = ADCR;        //»ñÈ¡ADCµÄÖµ
 371          //  return ADC_Temp;
 372          // }
 373          
 374          /***************************************************************************************
 375            * @ËµÃ÷   ÏµÍ³Ê±ÖÓ¼ÆÊıº¯Êı
 376            * @²ÎÊı   ÎŞ
 377            * @·µ»ØÖµ ÎŞ
 378            * @×¢     ÎŞ
 379          ***************************************************************************************/
 380          /*
 381          void System_Time_Cnt(void)
 382          {
 383              static u32 Timer1Count1 = 0;
 384              static u8 Timer1Count2 = 0;
 385              u32 Tampe = 1;
 386              if(Timer1_FLAG)              //1ms
 387              {
 388                  Timer1_FLAG = 0;
 389                  Timer1Count1 ++;
 390                  Tampe = Timer1Count1 % 10;
 391                  if(Tampe == 0)
 392                      Time_10mS_FLAG = 1;
 393                  Tampe = Timer1Count1 % 100;
 394                  if(Tampe == 0)
 395                      Time_100mS_FLAG = 1;
 396                  Tampe = Timer1Count1 % 200;
 397                  if(Tampe == 0)
 398                      Time_200mS_FLAG = 1;
 399                  Tampe = Timer1Count1 % 500;
 400                  if(Tampe == 0)
 401                      Time_500mS_FLAG = 1;
 402                  Tampe = Timer1Count1 % 1000;
 403                  if(Tampe == 0)
 404                      Time_1S_FLAG = 1;
 405                  Tampe = Timer1Count1 % 10000;
 406                  if(Tampe == 0)
 407                  {
 408                      Time_10S_FLAG = 1;
 409                      Timer1Count1 = 0;
 410                      Timer1Count2 ++;
 411                      Tampe = Timer1Count2 % 6;
 412                      if(Tampe == 0)
 413                          Time_1Min_FLAG = 1;
 414                      Tampe = Timer1Count2 % 60;
 415                      if(Tampe == 0)
 416                      {
 417                          Time_1H_FLAG = 1;
 418                          Timer1Count2 = 0;
 419                      }
 420                  }
 421              }
 422          }
 423          */
 424          
C51 COMPILER V9.52.0.0   HC_MCU_XBR                                                        01/18/2021 13:48:15 PAGE 8   

 425          /***************************************************************************************
 426            * @ËµÃ÷   ÏµÍ³ÈÎÎñ´¦Àíº¯Êı
 427            * @²ÎÊı   ÎŞ
 428            * @·µ»ØÖµ ÎŞ
 429            * @×¢     ÎŞ
 430          ***************************************************************************************/
 431          
 432          /*
 433          void System_Task(void)
 434          {
 435              u8 temp;
 436              if(Time_10mS_FLAG)
 437              {
 438                  Time_10mS_FLAG = 0;
 439                  //User TASK
 440                  
 441                  
 442                  //User TASK
 443                  if(Time_100mS_FLAG)
 444                  {
 445                      Time_100mS_FLAG = 0;
 446                      //User TASK
 447          
 448                  
 449                  
 450                      //User TASK
 451                  }
 452                  if(Time_200mS_FLAG)
 453                  {
 454                      Time_200mS_FLAG = 0;
 455                      //User TASK
 456          
 457                  
 458                  
 459                      //User TASK
 460                  }
 461                  if(Time_500mS_FLAG)
 462                  {
 463                      Time_500mS_FLAG = 0;
 464                      //User TASK
 465                      AN1_Data = Read_ADC(0x01);
 466                    
 467                      //User TASK
 468                  }
 469                   if(Time_1S_FLAG)
 470                  {
 471                      Time_1S_FLAG = 0;
 472                      //User TASK
 473          
 474                      temp = 0xFF & (AN1_Data >> 8);
 475                      SBUF = temp;
 476                      while(!(SCON & 0x02));
 477                      SCON &=~ 0x02;                 //Çå³ı·¢ËÍÖĞ¶Ï±êÖ¾Î»
 478                      temp = 0xFF & AN1_Data;
 479                      SBUF = temp;
 480                      while(!(SCON & 0x02));
 481                      SCON &=~ 0x02;                 //Çå³ı·¢ËÍÖĞ¶Ï±êÖ¾Î»
 482                      P0_0 =~ P0_0; 
 483                      //User TASK
 484                      
 485                  }
 486                  if(Time_10S_FLAG)
C51 COMPILER V9.52.0.0   HC_MCU_XBR                                                        01/18/2021 13:48:15 PAGE 9   

 487                  {
 488                      Time_10S_FLAG = 0;
 489                      //User TASK
 490                      
 491          
 492                      //User TASK
 493                  }
 494                  if(Time_1Min_FLAG)
 495                  {
 496                      Time_1Min_FLAG = 0;
 497                      //User TASK
 498                  
 499                  
 500                  
 501                      //User TASK
 502                  }
 503                  if(Time_1H_FLAG)
 504                  {
 505                      Time_1H_FLAG = 0;
 506                      //User TASK
 507                  
 508                  
 509                  
 510                      //User TASK
 511                  }
 512              }
 513          }
 514          */
 515          
 516          void send_data(u8 d)
 517          {
 518   1        SBUF = d;
 519   1        while (!(SCON & 0x02))
 520   1          ;
 521   1        SCON &= ~0x02;
 522   1      }
 523          
 524          //return 8-bit adc raw
 525          uchar read_ad(uchar ch)
 526          {
 527   1        u8 i;
 528   1        uint ad_sum;
 529   1      
 530   1        //  switch (ch)
 531   1        //  {
 532   1        //    case 3:
 533   1        //      ADC_P16_AN3;
 534   1        //      break;
 535   1        //    case 4:
 536   1        //      ADC_P15_AN4;
 537   1        //      break;
 538   1        //    case 5:
 539   1        //      ADC_P14_AN5;
 540   1        //      break;
 541   1        //  }
 542   1      
 543   1        //  if(ch==3)
 544   1        //  {
 545   1        //    ADC_P16_AN3;
 546   1        //  }
 547   1        //  else if(ch==4)
 548   1        //  {
C51 COMPILER V9.52.0.0   HC_MCU_XBR                                                        01/18/2021 13:48:15 PAGE 10  

 549   1        //    ADC_P15_AN4;
 550   1        //  }
 551   1      
 552   1        ADCC1 = ch;    //Ñ¡ÔñÍâ²¿Í¨µÀ
 553   1        ADCC0 |= 0x40; //Æô¶¯ADC×ª»»
 554   1        while (!(ADCC0 & 0x20))
 555   1          ;     //µÈ´ıADC×ª»»½áÊø
 556   1        ADCC0 &= ~0x20; //Çå³ı±êÖ¾Î»
 557   1      
 558   1        //ADC_Temp = ADCR;        //»ñÈ¡ADCµÄÖµ
 559   1      
 560   1        //  delay_ms(1);
 561   1        //
 562   1        //  ADC_TG;
 563   1        Delay_us(100);
 564   1      
 565   1        ad_sum = 0;
 566   1        //ADC_INT_IF_CLR; //ÇåÖĞ¶Ï±êÖ¾Î»
 567   1      
 568   1        for (i = 0; i < 16; i++)
 569   1        {
 570   2          //    ADC_TG;
 571   2          //    while(ADC_IF==0){};
 572   2          //    //adc_data = ADC_DATA_RD();
 573   2          //
 574   2          //    k=ADC_DH;
 575   2          //    k =k <<8;
 576   2          //    k+=ADC_DL;
 577   2          //
 578   2          //    ADC_INT_IF_CLR; //ÇåÖĞ¶Ï±êÖ¾Î»
 579   2          //    ad_sum+=k;
 580   2      
 581   2          ADCC0 |= 0x40; //Æô¶¯ADC×ª»»
 582   2          while (!(ADCC0 & 0x20))
 583   2            ;     //µÈ´ıADC×ª»»½áÊø
 584   2          ADCC0 &= ~0x20; //Çå³ı±êÖ¾Î»
 585   2          ad_sum += ADCR; //»ñÈ¡ADCµÄÖµ
 586   2      
 587   2          Delay_us(20);
 588   2        }
 589   1      
 590   1        //ADC_P14_AN5;
 591   1        ADCC1 = 1; //ÇĞ»»µ½an1
 592   1        i = ad_sum >> 8;
 593   1      
 594   1        Delay_us(100);
 595   1        return (i);
 596   1      }
 597          
 598          void set_var(void)
 599          {
 600   1      
 601   1        Flash_ReadArr(0X2f00, 12, guc_Read_a); //¶ÁÈ¡µØÖ·0x2F00ËùÔÚÉÈÇø
 602   1      
 603   1        TH = guc_Read_a[0];
 604   1        TH <<= 8;
 605   1        TH += guc_Read_a[1];
 606   1        TH *= 1000;
 607   1        if (TH < TH_LOW || TH > TH_HIGH)
 608   1          TH = TH_DEF;
 609   1      
 610   1        LIGHT_TH = guc_Read_a[2];
C51 COMPILER V9.52.0.0   HC_MCU_XBR                                                        01/18/2021 13:48:15 PAGE 11  

 611   1      
 612   1        if (LIGHT_TH == 0)
 613   1          LIGHT_TH = LIGHT_TH0;
 614   1        else if (LIGHT_TH == 0XFE)
 615   1          LIGHT_TH = 255;
 616   1      
 617   1        DELAY_NUM = guc_Read_a[3];
 618   1        DELAY_NUM <<= 8;
 619   1        DELAY_NUM += guc_Read_a[4];
 620   1        if (DELAY_NUM == 0 || DELAY_NUM > MAX_DELAY)
 621   1          DELAY_NUM = 5;
 622   1      
 623   1        //DELAY_NUM<<=2;
 624   1        lightvalue = guc_Read_a[5];
 625   1        //if(lightvalue>100)lightvalue=10;
 626   1        XRBoffbrightvalue = lightvalue;
 627   1      
 628   1        lowlightDELAY_NUM = guc_Read_a[6];
 629   1        if (lowlightDELAY_NUM == 0 || lowlightDELAY_NUM > 255)
 630   1          lowlightDELAY_NUM = 1;
 631   1      
 632   1        SWITCHfXBR = (~guc_Read_a[7]) & 0x01;
 633   1        
 634   1        Linkage_flag = (guc_Read_a[8]) & 0x01;
 635   1        
 636   1        SWITCHflag2 = (guc_Read_a[9]) & 0x01;
 637   1        
 638   1        all_day_micro_light_enable = (guc_Read_a[10]) & 0x01;
 639   1        //  addr = guc_Read_a[7];
 640   1        //
 641   1        //  devgroup = guc_Read_a[8];
 642   1      
 643   1        //  addrend = guc_Read_a[9];
 644   1      
 645   1        Flash_ReadArr(0X2f80, 2, guc_Read_a1); //¶ÁÈ¡µØÖ·0x2F00ËùÔÚÉÈÇø
 646   1        resetbtcnt = guc_Read_a1[0];
 647   1        zigbee_join_cnt = guc_Read_a1[1];
 648   1        savevar();
 649   1        if (0 == zigbee_join_cnt)
 650   1        {
 651   2          mcu_network_start();
 652   2        }
 653   1      }
 654          
 655          void XBRHandle(void)
 656          {
 657   1        u16 k;
 658   1      
 659   1        if (while_1flag == 0)
 660   1        {
 661   2          //send_data(0x66);
 662   2          //        ADC_TG;
 663   2          //        while(ADC_IF==0){};
 664   2          //        //adc_data = ADC_DATA_RD();
 665   2          //
 666   2          //        k = ADC_DH<<8;
 667   2          //        //adc_data =adc_data <<8;
 668   2          //        k+= ADC_DL;
 669   2          //
 670   2          //        ADC_INT_IF_CLR; //ÇåÖĞ¶Ï±êÖ¾Î»
 671   2      
 672   2          ADCC0 |= 0x40; //Æô¶¯ADC×ª»»
C51 COMPILER V9.52.0.0   HC_MCU_XBR                                                        01/18/2021 13:48:15 PAGE 12  

 673   2          while (!(ADCC0 & 0x20))
 674   2            ;     //µÈ´ıADC×ª»»½áÊø
 675   2          ADCC0 &= ~0x20; //Çå³ı±êÖ¾Î»
 676   2          k = ADCR;   //»ñÈ¡ADCµÄÖµ
 677   2      
 678   2          times++;
 679   2      
 680   2          SUM += k;
 681   2      
 682   2          //¼ÆËãĞÅºÅÖµÓëÖ±Á÷µçÑ¹Æ«²îÖµ
 683   2          if (k > average)
 684   2          {
 685   3            k -= average;
 686   3          }
 687   2          else
 688   2          {
 689   3            k = average - k;
 690   3          }
 691   2          SUM1 += k;
 692   2      
 693   2          if ((times & 0x1ff) == 0) //Ã¿256´ÎÑ­»·¼ì²éÒ»´Î¹âÃô
 694   2          {
 695   3            if (LIGHT > 0) //ÕıÔÚ°éÁÁµÄ¹ı³ÌÖĞ
 696   3            {
 697   4      
 698   4              //LIGHT++;
 699   4      
 700   4              if (slowchcnt < 100)
 701   4              {
 702   5                slowchcnt = slowchcnt + 2; //
 703   5                if (slowchcnt > 100)
 704   5                {
 705   6                  slowchcnt = 100;
 706   6                }
 707   5              }
 708   4              PWM3init(slowchcnt);
 709   4            }
 710   3            else if (LIGHT_off == 1) //else if((SWITCHflag2==0)&&(LIGHT_off ==1))
 711   3            {
 712   4              if (slowchcnt > lightvalue)
 713   4              {
 714   5                if (slowchcnt >= 2)
 715   5                  slowchcnt -= 2;
 716   5                if (slowchcnt < lightvalue)
 717   5                  slowchcnt = lightvalue;
 718   5              }
 719   4              PWM3init(slowchcnt);
 720   4            }
 721   3          }
 722   2      
 723   2          if (times >= 8192) //Ã¿250msµü´ú¼°ÅĞ¶ÏÒ»´Î
 724   2          {
 725   3      
 726   3            WDTC |= 0x10; //Çå¿´ÃÅ¹·
 727   3      
 728   3            times = 0;
 729   3      
 730   3            calc_average_times++;
 731   3      
 732   3            SUM16 += SUM;
 733   3      
 734   3            if (calc_average_times >= 8) //Ã¿2.5SÖØĞÂ¼ÆËãÒ»´ÎÖ±Á÷µçÑ¹Öµ
C51 COMPILER V9.52.0.0   HC_MCU_XBR                                                        01/18/2021 13:48:15 PAGE 13  

 735   3            {
 736   4              calc_average_times = 0;
 737   4      
 738   4              SUM16 >>= 16;
 739   4              //SUM16/=96000;//102400;
 740   4              average += SUM16;
 741   4              average /= 2;
 742   4              SUM16 = 0;
 743   4            }
 744   3      
 745   3            if (check_light_times < 8) //2s ¶ÁÈ¡Ò»´Î¸Ğ¹âADÖµ£¬Ë²Ê±¶Ô±ÈÖµÃ¿2s×óÓÒ¸üĞÂÒ»´Î
 746   3            {
 747   4              check_light_times++;
 748   4            }
 749   3            else
 750   3            {
 751   4              if (LIGHT == 0)
 752   4              {
 753   5                //light_ad=READ_LIGHT();
 754   5                light_ad = read_ad(10); //ÇĞ»»µ½an10
 755   5      
 756   5                if ((light_ad <= (light_ad0 + 2)) && (light_ad0 <= (light_ad + 2)))
 757   5                  light_ad = light_ad0;
 758   5      
 759   5                light_ad0 = light_ad;
 760   5      
 761   5                check_light_times = 0;
 762   5              }
 763   4            }
 764   3      
 765   3            if (SUM0 == 0)
 766   3            {
 767   4              SUM0 = SUM1 + 5000;
 768   4              if (start_times == 0 && SUM0 > 1000000)
 769   4                SUM0 = 1000000; //Éè¼Æ³õÖµ
 770   4            }
 771   3      
 772   3            if (SUM1_counter == 0)
 773   3            {
 774   4              SUM10 = SUM1;
 775   4              MAX_DELTA = 1; //SUM10>>3;
 776   4                       //if(MAX_DELTA<MAX_DELTA0)MAX_DELTA=MAX_DELTA0;
 777   4            }
 778   3      
 779   3            if ((SUM10 < (SUM1 + MAX_DELTA)) && (SUM1 < (SUM10 + MAX_DELTA))) //???????????
 780   3            {
 781   4              SUM1_counter++;
 782   4              ALL_SUM1 += SUM1;
 783   4              SUM10 = ALL_SUM1 / SUM1_counter;
 784   4              MAX_DELTA = SUM10 >> 3; //µü´úÍ»±ä(×î´óÆ«²îÖµ)
 785   4              if (MAX_DELTA < MAX_DELTA0)
 786   4                MAX_DELTA = MAX_DELTA0;
 787   4              if (MAX_DELTA > MAX_DELTA1)
 788   4                MAX_DELTA = MAX_DELTA1; //±£Ö¤×î´óÆ«²îÖµÔÚÒ»¶¨·¶Î§ÄÚ
 789   4      
 790   4              if (SUM0 > SUM10)
 791   4              {
 792   5                SUM = SUM0 - SUM10;
 793   5                if (SUM > 80000)
 794   5                  SUM0_num = 6;
 795   5                else if (SUM > 40000)
 796   5                  SUM0_num = 9;
C51 COMPILER V9.52.0.0   HC_MCU_XBR                                                        01/18/2021 13:48:15 PAGE 14  

 797   5                else
 798   5                  SUM0_num = 12;
 799   5              }
 800   4              else
 801   4              {
 802   5                SUM0_num = 12;
 803   5              }
 804   4      
 805   4              if ((SUM1_counter >= SUM0_num) && (SUM10 < SUM0))
 806   4              {
 807   5                if (SUM1_num > 16) //???????????????
 808   5                {
 809   6                  if (SUM0_num <= 9)
 810   6                    SUM0 = SUM10;
 811   6                  else if (SUM0 > (SUM10 + 4000))
 812   6                  {
 813   7                    SUM0 += SUM10;
 814   7                    SUM0 /= 2;
 815   7                  }
 816   6                  SUM1_counter = 0;
 817   6                  ALL_SUM1 = 0;
 818   6                }
 819   5              }
 820   4      
 821   4              else if (SUM1_counter >= SUM1_num)
 822   4              {
 823   5      
 824   5                //              if(SUM0>SUM10)
 825   5                //              {
 826   5                //                if(SUM1_num>16)SUM0=SUM10;  //???????????????
 827   5                //              }
 828   5                //              else
 829   5      
 830   5                if (SUM10 > (SUM0 + 4000))
 831   5                {
 832   6                  SUM = SUM10 - SUM0;
 833   6      
 834   6                  if ((SUM10 < 8000000) && (SUM < 400000))
 835   6                  //????????????,???????????????100000?,???????
 836   6                  {
 837   7                    if (SUM1_num > 16) //????????????
 838   7                    {
 839   8                      SUM0 += SUM10;
 840   8                      SUM0 /= 2;
 841   8                    }
 842   7                    else
 843   7                    {
 844   8                      if (SUM > 300000)
 845   8                        SUM1_num = 16;
 846   8                      else if (SUM > 150000)
 847   8                        SUM1_num = 12;
 848   8                      else
 849   8                        SUM1_num = 8;
 850   8                      if (SUM1_counter >= SUM1_num)
 851   8                      {
 852   9                        SUM0 += SUM10;
 853   9                        SUM0 /= 2;
 854   9                      }
 855   8                    }
 856   7                  }
 857   6                }
 858   5                //              else if((LIGHT>0)&&(TH==TH_LOW))
C51 COMPILER V9.52.0.0   HC_MCU_XBR                                                        01/18/2021 13:48:15 PAGE 15  

 859   5                //              {
 860   5                //                SUM=SUM10-SUM0;
 861   5                //                TH+=SUM;    //?????????????
 862   5                //              }
 863   5      
 864   5                if (SUM1_counter >= SUM1_num)
 865   5                {
 866   6                  SUM1_counter = 0;
 867   6                  ALL_SUM1 = 0;
 868   6                }
 869   5              }
 870   4            }
 871   3            else
 872   3            {
 873   4              SUM1_counter = 0;
 874   4              ALL_SUM1 = 0;
 875   4            }
 876   3      
 877   3            if (stop_times > 0) //
 878   3            {
 879   4              stop_times--;
 880   4              if ((SUM0 > (SUM01 + 6000)) && (SUM1 < (SUM01 + 15000)))
 881   4                SUM0 = SUM01 + 6000;
 882   4            }
 883   3            else
 884   3            {
 885   4      
 886   4              if (start_times > 0)
 887   4              {
 888   5                start_times--;
 889   5      
 890   5                if (start_times > 0) //???????????,???????250*88ms=22S?????????
 891   5                {
 892   6                  //start_times++;
 893   6                  /*
 894   6                    if(SUM0>600000)
 895   6                    {
 896   6                      TH=10000;
 897   6                    }
 898   6                    else */
 899   6                  if (SUM0 > 8000000)
 900   6                  {
 901   7                    TH = 800000;
 902   7                  }
 903   6                  else
 904   6                  {
 905   7                    SUM = SUM0 + TH;
 906   7                    if (SUM > 9000000)
 907   7                    {
 908   8                      TH = 9000000 - SUM0;
 909   8                    }
 910   7                    //if(TH<30000)TH=30000;
 911   7                  }
 912   6                }
 913   5                else
 914   5                {
 915   6                  //TH=TH_LOW;
 916   6                  //start_times=0;
 917   6                  //              EA=0;
 918   6                  //              set_var();
 919   6                  //              EA=1;
 920   6                }
C51 COMPILER V9.52.0.0   HC_MCU_XBR                                                        01/18/2021 13:48:15 PAGE 16  

 921   5              }
 922   4      
 923   4              if (SUM1 > (SUM0 + TH))
 924   4              {
 925   5                //SUM=SUM1-SUM0;
 926   5      
 927   5                //  if(SUM>TH)
 928   5                //  {
 929   5                if ((light_ad <= LIGHT_TH) || (start_times > 0))
 930   5                {
 931   6                  //                send_data(0xaa);
 932   6      
 933   6                  //if(alarm_times<2)
 934   6                  //{
 935   6                  //  alarm_times++;
 936   6                  //    }
 937   6                  //if(alarm_times>=2)  //??????????????
 938   6                  {
 939   7                    if (LIGHT == 0)
 940   7                      SUM01 = SUM0;
 941   7                    LIGHT = 1;
 942   7                    Light_on_flag = 1;
 943   7                    //PC3=0;
 944   7                    //LIGHT_ON;
 945   7                    //slowchcnt = slowchcnt+20;//
 946   7                    //if(slowchcnt>100)
 947   7                    //{
 948   7                    //  slowchcnt = 100;
 949   7                    //}
 950   7                    //PWM3init(slowchcnt);
 951   7                    //P0_6=0;
 952   7                    //                  send_data(0xaa);
 953   7                    //                  send_data((TH/1000)>>8);
 954   7                    //                  send_data((TH/1000)&0xff);
 955   7                    //                  send_data(LIGHT_TH);
 956   7                    //                  send_data(DELAY_NUM>>10);
 957   7                    //                  send_data(DELAY_NUM>>2);    //²âÊÔÓÃ
 958   7                    //                  send_data(slowchcnt);
 959   7                    //                  send_data(0xaa);
 960   7                    //send_data(0xdd);
 961   7                    radar_trig_times++;
 962   7                    //mcu_dp_value_update(DPID_RADAR_TRIGGER_TIMES,radar_trig_times);
 963   7                    radar_number_send_flag2 = 1;
 964   7      
 965   7                    SUM1_num = 8;
 966   7                    LIGHT_off = 0;
 967   7                    light1scount = 0;
 968   7                    light1sflag = 0;
 969   7                    //                send_data(0xaa);
 970   7                  }
 971   6                }
 972   5              }
 973   4            }
 974   3      
 975   3            //SUM2 = SUM1;
 976   3            
 977   3            //send_data(average >> 4);
 978   3            //send_data(light_ad);
 979   3            //send_data(SUM0 >> 16);
 980   3            //send_data(SUM0 >> 8);
 981   3            //send_data(SUM2 >> 16);
 982   3            //send_data(SUM2 >> 8); //20200927  ²âÊÔÓÃ
C51 COMPILER V9.52.0.0   HC_MCU_XBR                                                        01/18/2021 13:48:15 PAGE 17  

 983   3      
 984   3            SUM = 0;
 985   3            SUM1 = 0;
 986   3      
 987   3            if (LIGHT > 0) //????
 988   3            {
 989   4      
 990   4              //LIGHT++;
 991   4      
 992   4              //          slowchcnt = slowchcnt+5;//
 993   4              //          if(slowchcnt>=100)
 994   4              //          {
 995   4              //            slowchcnt = 100;
 996   4              //          }
 997   4              //          PWM3init(slowchcnt);
 998   4      
 999   4              if (LIGHT > DELAY_NUM)
1000   4              {
1001   5                LIGHT = 0;
1002   5                while_1flag = 1;
1003   5                Light_on_flag = 0;
1004   5                Light_on_flagpre = 0;
1005   5                //while_2flag = 0;
1006   5                //break;
1007   5              }
1008   4            }
1009   3          }
1010   2        }
1011   1        else
1012   1        {
1013   2          LIGHT_off = 1;
1014   2          while_1flag = 0;
1015   2          //if(while_2flag==0)
1016   2          //{
1017   2          //  while_2flag = 1;
1018   2          //          send_data(0x55);
1019   2          //}
1020   2          //PC3=1;
1021   2          //LIGHT_OFF;
1022   2          //slowchcnt = lightvalue;
1023   2          //PWM3init(lightvalue);
1024   2          lowlight1mincount = 0;
1025   2          lowlight1minflag = 0;
1026   2      
1027   2          //P0_6=1;
1028   2          //send_data(0x55);
1029   2          Delay_ms(250);
1030   2      
1031   2          //    SUM=0;
1032   2          //    SUM1=0;
1033   2          //    times=0;
1034   2      
1035   2          SUM16 = 0;
1036   2          calc_average_times = 0;
1037   2          SUM1_num = 64;
1038   2      
1039   2          stop_times = 2;
1040   2          //if(start_times==0)TH=TH_LOW;
1041   2          check_light_times = 6;
1042   2      
1043   2          SUM1_counter = 0;
1044   2          ALL_SUM1 = 0;
C51 COMPILER V9.52.0.0   HC_MCU_XBR                                                        01/18/2021 13:48:15 PAGE 18  

1045   2      
1046   2          //    send_data(0xdd);
1047   2          //    send_data(0xdd);
1048   2        }
1049   1      }
1050          
1051          void wait1(void)
1052          {
1053   1        u8 i, j;
1054   1      
1055   1        //µÈ´ıÖ±Á÷µçÑ¹ÎÈ¶¨
1056   1        j = 0;
1057   1        while (1)
1058   1        {
1059   2          SUM = 0;
1060   2      
1061   2          //    for(i=0;i<4;i++)  //0.52s
1062   2          //    {
1063   2          //      for(t=0;t<8192;t++) //0.13s
1064   2          //      {
1065   2      
1066   2          //        ADCC0 |= 0x40;          //Æô¶¯ADC×ª»»
1067   2          //        while(!(ADCC0&0x20));   //µÈ´ıADC×ª»»½áÊø
1068   2          //        ADCC0 &=~ 0x20;         //Çå³ı±êÖ¾Î»
1069   2          //        k = ADCR;       //»ñÈ¡ADCµÄÖµ
1070   2          //
1071   2          //        SUM+=k;
1072   2          //
1073   2          //      }
1074   2          //
1075   2          //      WDTC |= 0x10;   //Çå¿´ÃÅ¹·
1076   2      
1077   2          for (i = 0; i < 128; i++) //
1078   2          {
1079   3      
1080   3            ADCC0 |= 0x40; //Æô¶¯ADC×ª»»
1081   3            while (!(ADCC0 & 0x20))
1082   3              ;     //µÈ´ıADC×ª»»½áÊø
1083   3            ADCC0 &= ~0x20; //Çå³ı±êÖ¾Î»
1084   3            //k = ADCR;       //»ñÈ¡ADCµÄÖµ
1085   3      
1086   3            SUM += ADCR;
1087   3          }
1088   2      
1089   2          //·¢ËÍ¸Ğ¹âADÖµ
1090   2          //        send_byte=0xFA;
1091   2          //        check_sum=send_byte;
1092   2          //        send_data(send_byte);
1093   2      
1094   2          //        //send_byte=light_ad;
1095   2          //        check_sum+=light_ad;
1096   2          //        send_data(light_ad);
1097   2      
1098   2          //        check_sum+=light_ad;
1099   2          //        send_data(light_ad);
1100   2          //
1101   2          //        check_sum+=1;
1102   2          //        send_data(check_sum);
1103   2      
1104   2          //}
1105   2      
1106   2          Delay_ms(400);
C51 COMPILER V9.52.0.0   HC_MCU_XBR                                                        01/18/2021 13:48:15 PAGE 19  

1107   2      
1108   2          //WDTC |= 0x10;   //Çå¿´ÃÅ¹·
1109   2      
1110   2          i = SUM >> 11;
1111   2          if ((i > 12) && (i < 141) && (j > 20))
1112   2            break;
1113   2      
1114   2          j++;
1115   2      
1116   2          if (j > 80)
1117   2            break; //??35????????????1.1V???????
1118   2        }
1119   1      }
1120          void wait2(void)
1121          {
1122   1        u8 i;
1123   1        //u8 j;
1124   1        u16 k, t;
1125   1      
1126   1        SUM = 0;
1127   1      
1128   1        for (i = 0; i < 8; i++)
1129   1        {
1130   2          for (t = 0; t < 8192; t++)
1131   2          {
1132   3            //        ADC_TG;
1133   3            //        while(ADC_IF==0){};
1134   3            //        //adc_data = ADC_DATA_RD();
1135   3            //
1136   3            //        k = ADC_DH<<8;
1137   3            //        //adc_data =adc_data <<8;
1138   3            //        k+= ADC_DL;
1139   3            //
1140   3            //        ADC_INT_IF_CLR; //ÇåÖĞ¶Ï±êÖ¾Î»
1141   3      
1142   3            ADCC0 |= 0x40; //Æô¶¯ADC×ª»»
1143   3            while (!(ADCC0 & 0x20))
1144   3              ;     //µÈ´ıADC×ª»»½áÊø
1145   3            ADCC0 &= ~0x20; //Çå³ı±êÖ¾Î»
1146   3            k = ADCR;   //»ñÈ¡ADCµÄÖµ
1147   3      
1148   3            SUM += k;
1149   3          }
1150   2          WDTC |= 0x10; //Çå¿´ÃÅ¹·
1151   2        }
1152   1      
1153   1        average = SUM >> 16;
1154   1      
1155   1        //  light_ad=read_ad(10);
1156   1        //  light_ad0=light_ad;
1157   1      
1158   1        //  Delay_ms(4);  //4ms
1159   1      }
1160          
1161          unsigned char PWM3init(unsigned char ab)
1162          {
1163   1        float i11;
1164   1        unsigned char j11;
1165   1      
1166   1        if (0 == ab)
1167   1        {
1168   2          light_status_xxx = 1;
C51 COMPILER V9.52.0.0   HC_MCU_XBR                                                        01/18/2021 13:48:15 PAGE 20  

1169   2          person_in_range_flag = 0;
1170   2        }
1171   1        else if (100 == ab)
1172   1        {
1173   2          light_status_xxx = 0;
1174   2          person_in_range_flag = 1;
1175   2        }
1176   1        else
1177   1        {
1178   2          light_status_xxx = 2;
1179   2          person_in_range_flag = 1;
1180   2        }
1181   1        
1182   1        if (1 == ab)
1183   1        {
1184   2          j11 = 0;
1185   2        }
1186   1        else
1187   1        {
1188   2          i11 = ab * 255 / 100;
1189   2          j11 = (unsigned char )(i11 + 0.5);
1190   2        }
1191   1        
1192   1      #ifdef V11
                /************************************PWM3³õÊ¼»¯****************************************/
                //P0M3 = P0M3&0xF0|0x08;    //P06ÉèÖÃÎªÍÆÍìÊä³ö
                PWM3_MAP = 0x05; //PWM3Ó³ÉäP05¿Ú
              
              #endif
1198   1      
1199   1      #ifdef V10
                PWM3_MAP = 0x06; //PWM3Ó³ÉäP05¿Ú
              
              #endif
1203   1      
1204   1      #ifdef V12
1205   1        PWM3_MAP = 0x10; //PWM3Ó³ÉäP10¿Ú
1206   1      
1207   1      #endif
1208   1      
1209   1        //ÖÜÆÚ¼ÆËã  = 0xFF / (Fosc / PWM·ÖÆµÏµÊı)   £¨Fosc¼ûÏµÍ³Ê±ÖÓÅäÖÃµÄ²¿·Ö£©
1210   1        //      = 0xFF /(16000000 / 4)
1211   1        //      = 255 /4000000
1212   1        //      = 63.75us   ¼´15.69KHZ
1213   1      
1214   1        PWM3P = 0xFF; //PWMÖÜÆÚÎª0xFF
1215   1        //ÓĞĞ§µçÆ½Ê±¼ä¼ÆËã£¨¼´Õ¼¿Õ±È£©
1216   1        //      = 0x55 / (Fosc / PWM·ÖÆµÏµÊı)   £¨Fosc¼ûÏµÍ³Ê±ÖÓÅäÖÃµÄ²¿·Ö£©
1217   1        //      = 0x55 /(16000000 / 4)
1218   1        //      = 85 /4000000
1219   1        //      = 21.25us   Õ¼¿Õ±ÈÎª 21.25 / 63.75 = 34%
1220   1      
1221   1        PWM3D = j11;  //PWMÕ¼¿Õ±ÈÉèÖÃ
1222   1        PWM3C = 0x94; //Ê¹ÄÜPWM3£¬¹Ø±ÕÖĞ¶Ï£¬ÔÊĞíÊä³ö£¬Ê±ÖÓ16·ÖÆµ
1223   1      
1224   1        return 0;
1225   1      }
1226          
1227          void reset_bt_module(void);
1228          
1229          /***************************************************************************************
1230            * @ËµÃ÷   Ö÷º¯Êı
C51 COMPILER V9.52.0.0   HC_MCU_XBR                                                        01/18/2021 13:48:15 PAGE 21  

1231            * @²ÎÊı   ÎŞ
1232            * @·µ»ØÖµ ÎŞ
1233            * @×¢     ÎŞ
1234          ***************************************************************************************/
1235          void main()
1236          {
1237   1        u8 i;
1238   1        zigbee_protocol_init(); //mcu_sdk
1239   1        InitSYS();
1240   1        GPIO_Init();
1241   1        //LIGHT_ON;
1242   1        //P0_6=0;
1243   1        PWM3init(100);
1244   1        Timer_Init();
1245   1        UART1_Init();
1246   1        ADC_Init();
1247   1      
1248   1        LVDC = 0xAA; //LVDÉèÖÃ2.4V,½ûÖ¹ÖĞ¶Ï
1249   1        //  Ïû¶¶Ê±¼ä =  (0xFF + 2) * 1/Fcpu
1250   1        //       =  (0xFF + 2) / 16000000 £¨µ±Ç°µÄCPUÊ±ÖÓ£©
1251   1        //       =  16.0625us
1252   1        LVDDBC = 0xFF; //ÉèÖÃÏû¶¶Ê±¼ä
1253   1        LVDC &= ~0x08; //Çå³ıLVDÖĞ¶Ï±êÖ¾Î»
1254   1                 //
1255   1        EA = 1;
1256   1      
1257   1        Delay_ms(200);
1258   1      
1259   1        //LIGHT_ON;
1260   1        PWM3init(100);
1261   1        SWITCHflag = 1;
1262   1        light_ad = read_ad(10);
1263   1        light_ad0 = light_ad;
1264   1      
1265   1        EA = 0;
1266   1        set_var(); //´Óflash¶ÁÈ¡³ö±äÁ¿
1267   1      
1268   1        //for(i=0;i<5;i++)send_data(guc_Read_a[i]);
1269   1      
1270   1        //  TXdata[0]=VERSION;
1271   1        //  t=TH/1000;
1272   1        //  TXdata[1]=t>>8;
1273   1        //  TXdata[2]=t;
1274   1        //  TXdata[3]=LIGHT_TH;
1275   1        //  t=DELAY_NUM/4;
1276   1        //  TXdata[4]=t>>8;
1277   1        //  TXdata[5]=t;
1278   1      
1279   1        //  TXdata[6]=light_ad;
1280   1      
1281   1        //  for(i=0;i<7;i++)send_data(TXdata[i]);
1282   1        resetbtcnt++;
1283   1      
1284   1        Flash_EraseBlock(0x2F80);
1285   1        Delay_us_1(10000);
1286   1        FLASH_WriteData(resetbtcnt, 0x2F80);
1287   1        Delay_us_1(100);
1288   1      
1289   1        EA = 1;
1290   1      
1291   1        wait1();
1292   1      
C51 COMPILER V9.52.0.0   HC_MCU_XBR                                                        01/18/2021 13:48:15 PAGE 22  

1293   1        slowchcnt = lightvalue;
1294   1        //Delay_ms(200);
1295   1        PWM3init(lightvalue);
1296   1        //LIGHT_OFF;
1297   1        //P0_6=1;
1298   1        Delay_ms(300);
1299   1      
1300   1        wait2();
1301   1      
1302   1        SUM = 0;
1303   1        
1304   1        while (1)
1305   1        {
1306   2          Delay_ms(500);
1307   2          send_data(0xaa);
1308   2          send_data(0xae);
1309   2          
1310   2          if (resetbtcnt >= 3)  //ĞĞÎªÊÇÃ¿Èı´ÎÉÏµç»á¸´Î»Ò»´ÎÀ¶ÑÀÄ£¿é
1311   2          {
1312   3            resetbtcnt = 0;
1313   3            reset_bt_module();
1314   3          }
1315   2          
1316   2          // if (1 == check_group_flag)
1317   2          // {
1318   2            // check_group_flag = 0;
1319   2            if (light_status_xxx != light_status_xxx_last)
1320   2            {
1321   3              mcu_dp_enum_update(DPID_LIGHT_STATUS,light_status_xxx);
1322   3              light_status_xxx_last = light_status_xxx;
1323   3            }
1324   2            
1325   2            if (person_in_range_flag != person_in_range_flag_last)
1326   2            {
1327   3              mcu_dp_enum_update(DPID_PERSON_IN_RANGE,person_in_range_flag);
1328   3              person_in_range_flag_last = person_in_range_flag;
1329   3            }     
1330   2      
1331   2          // }
1332   2          
1333   2          if (1 == radar_number_send_flag)
1334   2          {
1335   3            if (1 == radar_number_send_flag2)
1336   3            {
1337   4              radar_number_send_flag = 0;
1338   4              radar_number_send_flag2 = 0;
1339   4              if (radar_trig_times_last != radar_trig_times)
1340   4              {
1341   5                mcu_dp_value_update(DPID_RADAR_TRIGGER_TIMES,radar_trig_times);
1342   5                radar_trig_times_last = radar_trig_times;
1343   5              }
1344   4            }
1345   3          }
1346   2      
1347   2      //    if (check_group_count <= 2) //Ò»ÉÏµç¼ä¸ôÒ»Ãë»ñÈ¡3´ÎÈº×éµØÖ·
1348   2      //    {
1349   2      //      if (check_group_flag == 1)
1350   2      //      {
1351   2      //        check_group_flag = 0;
1352   2      //        check_group_count++;
1353   2      
1354   2      //        send_data(0x55);
C51 COMPILER V9.52.0.0   HC_MCU_XBR                                                        01/18/2021 13:48:15 PAGE 23  

1355   2      //        send_data(0xAA);
1356   2      //        send_data(0X00);
1357   2      //        send_data(0XB4); //ĞÂµÄÃüÁî×Ö£¬¹¦ÄÜ²»Ã÷
1358   2      //        send_data(0X00);
1359   2      //        send_data(0X00);
1360   2      //        send_data(0Xb3);
1361   2      //      }
1362   2      //    }
1363   2          WDTC |= 0x10; //Çå¿´ÃÅ¹·
1364   2      
1365   2          if (while_1flag == 0)
1366   2          {
1367   3            if ((times & 0x1f) == 0)
1368   3              zigbee_uart_service();
1369   3          }
1370   2      
1371   2          if (SWITCHfXBR == 1) //À×´ï¿ª, app¿ØÖÆ
1372   2          {
1373   3            if (while_2flag == 0)
1374   3            {
1375   4              while_1flag = 0;
1376   4      
1377   4              while_2flag = 1;
1378   4              slowchcnt = lightvalue;
1379   4      
1380   4              SUM16 = 0;
1381   4              calc_average_times = 0;
1382   4              SUM1_num = 64;
1383   4      
1384   4              stop_times = 2;
1385   4              //if(start_times==0)TH=TH_LOW;
1386   4              check_light_times = 6;
1387   4      
1388   4              SUM1_counter = 0;
1389   4              ALL_SUM1 = 0;
1390   4            }
1391   3      
1392   3            XBRHandle();
1393   3      
1394   3            if (LIGHT_off > 0) //¹ØµÆÑÓÊ±
1395   3            {
1396   4              if (lowlight1minflag == 1)
1397   4              {
1398   5                lowlight1minflag = 0;
1399   5                LIGHT_off++;
1400   5                if (LIGHT_off >= lowlightDELAY_NUM)
1401   5                {
1402   6                  LIGHT_off = 0;
1403   6                  if (1 == all_day_micro_light_enable)
1404   6                  {
1405   7                    //
1406   7                  }
1407   6                  else
1408   6                  {
1409   7                    PWM3init(0);
1410   7                  }
1411   6                }
1412   5              }
1413   4            }
1414   3            if (LIGHT > 0) //ÁÁµÆÑÓÊ±
1415   3            {
1416   4              if (light1sflag == 1)
C51 COMPILER V9.52.0.0   HC_MCU_XBR                                                        01/18/2021 13:48:15 PAGE 24  

1417   4              {
1418   5                light1sflag = 0;
1419   5                LIGHT++;
1420   5                //slowchcnt = slowchcnt+20;//
1421   5                //          if(slowchcnt>100)
1422   5                //          {
1423   5                //            slowchcnt = 100;
1424   5                //          }
1425   5                //          PWM3init(slowchcnt);
1426   5              }
1427   4            }
1428   3      
1429   3            //Áª¶¯
1430   3            if (Linkage_flag == 1)
1431   3            {
1432   4              if (Light_on_flagpre != Light_on_flag)
1433   4              {
1434   5                Light_on_flagpre = Light_on_flag;
1435   5                LIGHT = 1;
1436   5                //PWM3init(100);
1437   5                for (i = 0; i < 8; i++)
1438   5                {
1439   6                  //if (groupaddr[i] != 0)
1440   6                  {
1441   7                    //mcu_dp_bool_mesh_update(DPID_SWITCH_LED2, SWITCHflag2, groupaddr[i]);
1442   7                  }
1443   6                }
1444   5              }
1445   4            }
1446   3          }
1447   2          else
1448   2          { //À×´ï¹Ø
1449   3            while_2flag = 0;
1450   3            if (SWITCHflag2 == 0) //¹ØµÆ
1451   3            {
1452   4              PWM3init(0);
1453   4            }
1454   3            else
1455   3            { //¿ªµÆ
1456   4              PWM3init(XRBoffbrightvalue);
1457   4      
1458   4              while_1flag = 0;
1459   4      
1460   4              slowchcnt = lightvalue;
1461   4              //PWM3init(lightvalue);
1462   4      
1463   4              SUM16 = 0;
1464   4              calc_average_times = 0;
1465   4              SUM1_num = 64;
1466   4      
1467   4              stop_times = 2;
1468   4              //if(start_times==0)TH=TH_LOW;
1469   4              check_light_times = 6;
1470   4      
1471   4              SUM1_counter = 0;
1472   4              ALL_SUM1 = 0;
1473   4            }
1474   3          }
1475   2        }
1476   1      
1477   1        //  while(1)
1478   1        //  {
C51 COMPILER V9.52.0.0   HC_MCU_XBR                                                        01/18/2021 13:48:15 PAGE 25  

1479   1        //    System_Time_Cnt();
1480   1        //    System_Task();
1481   1        //    WDTC |= 0x10;              //Çå¹·
1482   1        //  }
1483   1      }
1484          
1485          /***************************************************************************************
1486            * @ËµÃ÷   T1ÖĞ¶Ï·şÎñº¯Êı
1487            * @²ÎÊı   ÎŞ
1488            * @·µ»ØÖµ ÎŞ
1489            * @×¢     ÎŞ
1490          ***************************************************************************************/
1491          void TIMER1_Rpt(void) interrupt TIMER1_VECTOR
1492          {
1493   1        //Timer1_FLAG = 1;    //1mS
1494   1        Timer_Counter++;
1495   1      
1496   1        lowlight1mincount++;
1497   1        if (lowlight1mincount >= 60000)
1498   1        {
1499   2          lowlight1mincount = 0;
1500   2          lowlight1minflag = 1;
1501   2        }
1502   1        light1scount++;
1503   1        if (light1scount >= 1000)
1504   1        {
1505   2          //check_group_flag = 1;
1506   2          light1scount = 0;
1507   2          light1sflag = 1;
1508   2        }
1509   1        radar_number_count++;
1510   1        if (radar_number_count >= 1000)
1511   1        {
1512   2          radar_number_count = 0;
1513   2          radar_number_send_flag = 1;
1514   2        } 
1515   1      }
1516          
1517          /***************************************************************************************
1518            * @ËµÃ÷   UART1ÖĞ¶Ï·şÎñº¯Êı
1519            * @²ÎÊı   ÎŞ
1520            * @·µ»ØÖµ ÎŞ
1521            * @×¢     ÎŞ
1522          ***************************************************************************************/
1523          
1524          void UART1_Rpt(void) interrupt UART1_VECTOR
1525          {
1526   1        u8 i;
1527   1        //u16 t;
1528   1      
1529   1        if (SCON & 0x01) //ÅĞ¶Ï½ÓÊÕÖĞ¶Ï±êÖ¾Î»
1530   1        {
1531   2          i = SBUF;
1532   2          uart_receive_input(i); //mcu_sdk
1533   2          SCON &= ~0x01;       //Çå³ı½ÓÊÕÖĞ¶Ï±êÖ¾Î»
1534   2          EA = 1;
1535   2        }
1536   1      }
1537          
1538          void UART2_Rpt(void) interrupt UART2_VECTOR
1539          {
1540   1      }
C51 COMPILER V9.52.0.0   HC_MCU_XBR                                                        01/18/2021 13:48:15 PAGE 26  

1541          
1542          // void Delay_2us(u16 Cnt)
1543          // {
1544          //  while(Cnt--);
1545          // }
1546          #pragma disable
1547          void Flash_EraseBlock(unsigned int fui_Address)
1548          {
1549   1        while (1)
1550   1        {
1551   2          LVDC &= ~0x08; //Çå³ıLVDÖĞ¶Ï±êÖ¾Î»
1552   2          P0_0 = 0;
1553   2          if ((LVDC & 0x08) == 0)
1554   2            break;
1555   2        }
1556   1        P0_0 = 1;
1557   1        EA = 0;
1558   1        IAP_CMD = 0xF00F;   //Flash½âËø
1559   1        IAP_ADDR = fui_Address; //Ğ´Èë²Á³ıµØÖ·
1560   1        IAP_CMD = 0xD22D;   //Ñ¡Ôñ²Ù×÷·½Ê½£¬ ÉÈÇø²Á³ı
1561   1        IAP_CMD = 0xE11E;   //´¥·¢ºóIAP_ADDRL&IAP_ADDRHÖ¸Ïò0xFF£¬Í¬Ê±×Ô¶¯Ëø¶¨
1562   1                    //EA=1;
1563   1      }
1564          
1565          /**
1566            * @ËµÃ÷   Ğ´ÈëÒ»¸ö×Ö½ÚÊı¾İµ½FlashÀïÃæ
1567            *         ¸Ãº¯ÊıĞè¾ø¶ÔµØÖ·±àÒë£¬ÏêÇéÇë²éÔÄIAP²Ù×÷Ó¦ÓÃÊÖ²á
1568            * @²ÎÊı   fui_Address £ºFLASHµØÖ·
1569            * @²ÎÊı   fucp_SaveData£ºĞ´ÈëµÄÊı¾İ
1570            * @·µ»ØÖµ ÎŞ
1571            * @×¢     Ğ´Ö®Ç°±ØĞëÏÈ¶Ô²Ù×÷µÄÉÈÇø½øĞĞ²Á³ı
1572            */
1573          #pragma disable
1574          void FLASH_WriteData(unsigned char fuc_SaveData, unsigned int fui_Address)
1575          {
1576   1        while (1)
1577   1        {
1578   2          LVDC &= ~0x08; //Çå³ıLVDÖĞ¶Ï±êÖ¾Î»
1579   2          P0_0 = 0;
1580   2          if ((LVDC & 0x08) == 0)
1581   2            break;
1582   2        }
1583   1        P0_0 = 1;
1584   1        EA = 0;
1585   1        IAP_DATA = fuc_SaveData;
1586   1        IAP_CMD = 0xF00F; //Flash½âËø
1587   1        IAP_ADDR = fui_Address;
1588   1        IAP_CMD = 0xB44B; //×Ö½Ú±à³Ì
1589   1        IAP_CMD = 0xE11E; //´¥·¢Ò»´Î²Ù×÷
1590   1                  //EA=1;
1591   1      }
1592          
1593          /**
1594            * @ËµÃ÷   Ğ´ÈëÈÎÒâ³¤¶ÈµÄÊı¾İµ½FLASHÀïÃæ
1595            *         ¸Ãº¯ÊıĞè¾ø¶ÔµØÖ·±àÒë£¬ÏêÇéÇë²éÔÄIAP²Ù×÷Ó¦ÓÃÊÖ²á
1596            * @²ÎÊı   fui_Address £ºFLASHÆğÊ¼µØÖ·
1597            * @²ÎÊı   fuc_Length £º Ğ´ÈëÊı¾İ³¤¶È
1598            *         È¡Öµ·¶Î§£º0x00-0xFF
1599            * @²ÎÊı  *fucp_SaveArr£ºĞ´ÈëµÄÊı¾İ´æ·ÅÇøÓòµÄÊ×µØÖ·
1600            * @·µ»ØÖµ ÎŞ
1601            * @×¢     Ğ´Ö®Ç°±ØĞëÏÈ¶Ô²Ù×÷µÄÉÈÇø½øĞĞ²Á³ı
1602            */
C51 COMPILER V9.52.0.0   HC_MCU_XBR                                                        01/18/2021 13:48:15 PAGE 27  

1603          
1604          // void Flash_WriteArr(unsigned int fui_Address,unsigned char fuc_Length,unsigned char *fucp_SaveArr)
1605          // {
1606          //  unsigned char fui_i = 0;
1607          //  EA=0;
1608          //  for(fui_i=0;fui_i<fuc_Length;fui_i++)
1609          //  {
1610          //    FLASH_WriteData(*(fucp_SaveArr++), fui_Address++);
1611          //  }
1612          //  EA=1;
1613          // }
1614          
1615          /**
1616            * @ËµÃ÷   ´ÓFLASHÀïÃæ¶ÁÈ¡ÈÎÒâ³¤¶ÈµÄÊı¾İ
1617            * @²ÎÊı   fui_Address £ºFLASHÆğÊ¼µØÖ·
1618            * @²ÎÊı   fuc_Length £º¶ÁÈ¡Êı¾İ³¤¶È
1619            *         È¡Öµ·¶Î§£º0x00-0xFF
1620            * @²ÎÊı  *fucp_SaveArr£º¶ÁÈ¡Êı¾İ´æ·ÅµÄÇøÓòÊ×µØÖ·
1621            * @·µ»ØÖµ ÎŞ
1622            * @×¢     ÎŞ
1623            */
1624          
1625          
1626          void savevar(void)
1627          {
1628   1        unsigned char i;
1629   1        
1630   1        //EA=0;
1631   1        
1632   1        Flash_EraseBlock(0x2F00);
1633   1        Delay_us_1(10000);
1634   1      
1635   1        i=(TH/1000)>>8;
1636   1        FLASH_WriteData(i,0x2F00+0);
1637   1        Delay_us_1(100);
1638   1        
1639   1          i=(TH/1000)&0xff;
1640   1        FLASH_WriteData(i,0x2F00+1);
1641   1        Delay_us_1(100);
1642   1        
1643   1          i=LIGHT_TH;
1644   1        FLASH_WriteData(i,0x2F00+2);
1645   1        Delay_us_1(100);
1646   1        
1647   1        i=DELAY_NUM>>8;
1648   1        FLASH_WriteData(i,0x2F00+3);
1649   1        Delay_us_1(100);
1650   1        i=DELAY_NUM&0xff;//&0xff;
1651   1        FLASH_WriteData(i,0x2F00+4);
1652   1        Delay_us_1(100);
1653   1        
1654   1        i=lightvalue;
1655   1        FLASH_WriteData(i,0x2F00+5);
1656   1        Delay_us_1(100);
1657   1        
1658   1        i=lowlightDELAY_NUM;
1659   1        FLASH_WriteData(i,0x2F00+6);
1660   1        Delay_us_1(100);
1661   1        
1662   1        i=~SWITCHfXBR;//&0xff;
1663   1        FLASH_WriteData(i,0x2F00+7);
1664   1        Delay_us_1(100);
C51 COMPILER V9.52.0.0   HC_MCU_XBR                                                        01/18/2021 13:48:15 PAGE 28  

1665   1        
1666   1        i=Linkage_flag;
1667   1        FLASH_WriteData(i,0x2F00+8);
1668   1        Delay_us_1(100);  
1669   1        
1670   1        i=SWITCHflag2;
1671   1        FLASH_WriteData(i,0x2F00+9);
1672   1        Delay_us_1(100);  
1673   1        
1674   1        i=all_day_micro_light_enable;
1675   1        FLASH_WriteData(i,0x2F00+10);
1676   1        Delay_us_1(100);
1677   1        
1678   1      //  i=addr;//&0xff;
1679   1      //  FLASH_WriteData(i,0X2F00+7);
1680   1      //  Delay_us_1(100);
1681   1      //  
1682   1      //  i=devgroup;//&0xff;
1683   1      //  FLASH_WriteData(i,0X2F00+8);
1684   1      //  Delay_us_1(100);
1685   1      
1686   1      //  i=addrend;
1687   1      //  FLASH_WriteData(i,0X2F00+9);
1688   1      //  Delay_us_1(100);
1689   1        
1690   1        Flash_EraseBlock(0x2F80);
1691   1        Delay_us_1(10000);
1692   1        FLASH_WriteData(0,0x2F80+0);
1693   1        
1694   1        FLASH_WriteData(1,0x2F80+1);
1695   1        
1696   1        EA=1;       //-20200927
1697   1      
1698   1      }
1699          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   3720    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     98    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      4      26
   IDATA SIZE       =     12    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
