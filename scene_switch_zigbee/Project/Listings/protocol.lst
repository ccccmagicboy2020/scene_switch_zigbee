C51 COMPILER V9.52.0.0   PROTOCOL                                                          01/18/2021 13:48:16 PAGE 1   


C51 COMPILER V9.52.0.0, COMPILATION OF MODULE PROTOCOL
OBJECT MODULE PLACED IN .\Objects\protocol.obj
COMPILER INVOKED BY: d:\cccc2020\TOOL\Keil\C51\BIN\C51.EXE ..\User\protocol.c OPTIMIZE(9,SIZE) BROWSE DEBUG OBJECTEXTEND
                    - PRINT(.\Listings\protocol.lst) TABS(2) OBJECT(.\Objects\protocol.obj)

line level    source

   1          /**
   2          * @file  protocol.c
   3          * @brief this file contains protocol analysis and construct response function when received zigbee module 
             -send message
   4          * @author luchao
   5          * @date 2020.03.13
   6          * @par email:
   7          * luchao@tuya.com
   8          * @copyright HANGZHOU TUYA INFORMATION TECHNOLOGY CO.,LTD
   9          * @par company
  10          * http://www.tuya.com
  11          */
  12          
  13          #include "HC89S003F4.h"
  14          #include "zigbee.h"
  15          #include "string.h"
  16          #include <stdio.h>
  17          
  18          extern u8 xdata switchcnt;      //å¤ä½æ¨¡å—ç‚¹å‡»æ¬¡æ•°è®¡æ•°
  19          extern u8 xdata reset_bt_bn;    //å¤ä½æ¨¡å—çš„å…¨å±€å˜é‡
  20          extern u8 xdata SWITCHflag2;   //å¼€å…³ç¯çš„å˜é‡
  21          extern u8 xdata SWITCHfXBR;    //å¼€å…³é›·è¾¾çš„å˜é‡
  22          extern u8 xdata lightvalue;    //ç¯äº®å€¼
  23          extern u8 xdata XRBoffbrightvalue;  //å…³é›·è¾¾åçš„ç¯äº®å€¼
  24          extern ulong xdata TH;          //é›·è¾¾æ„Ÿåº”åå·®é˜ˆå€¼ï¼Œæ•°å€¼è¶Šå¤§ä»£è¡¨è¶Šä¸çµæ•
  25          extern u8 xdata LIGHT_TH;       //æ„Ÿå…‰é˜ˆå€¼
  26          extern u16 xdata DELAY_NUM;     //æ„Ÿåº”å»¶æ—¶ï¼Œå•ä½ä¸ºç§’
  27          extern u8 xdata lowlightDELAY_NUM;      //å…³ç¯å»¶æ—¶ï¼Œå•ä½ä¸ºåˆ†é’Ÿ
  28          extern u8 xdata light_ad;               //é‡‡åˆ°çš„å…‰æ„Ÿçš„ç¬æ—¶å€¼
  29          u8 xdata cdsvalue = 0;              //æ„Ÿå…‰é€‰æ‹©å€¼
  30          ulong xdata sensing_th = 0;     //é›·è¾¾æ„Ÿåº”é˜ˆå€¼ï¼Œæ•°å€¼è¶Šå¤§è¶Šçµæ•
  31          extern  u8 xdata Linkage_flag;  //è”åŠ¨çš„å¼€å…³çš„å…¨å±€
  32          extern  u8 xdata Light_on_flag; //
  33          
  34          extern u8 xdata all_day_micro_light_enable;
  35          extern u16 xdata radar_trig_times;
  36          extern u8 xdata light_status_xxx;
  37          extern u8 xdata person_in_range_flag;
  38          
  39          void send_data(u8 d);
  40          void reset_bt_module(void);
  41          unsigned char PWM3init(unsigned char ab);
  42          void savevar(void);
  43          void Flash_EraseBlock(unsigned int fui_Address);//flashæ‰‡åŒºæ“¦é™¤
  44          void FLASH_WriteData(unsigned char fuc_SaveData, unsigned int fui_Address);//flashå†™å…¥
  45          void Flash_WriteArr(unsigned int fui_Address,unsigned char fuc_Length,unsigned char *fucp_SaveArr);
  46          void Delay_us_1(uint q1);
  47          
  48          void reset_bt_module(void)
  49          {
  50   1        mcu_network_start();
  51   1      }
  52          /******************************************************************************
  53                                          ç§»æ¤é¡»çŸ¥:
C51 COMPILER V9.52.0.0   PROTOCOL                                                          01/18/2021 13:48:16 PAGE 2   

  54          1:MCUå¿…é¡»åœ¨whileä¸­ç›´æ¥è°ƒç”¨mcu_api.cå†…çš„zigbee_uart_service()å‡½æ•°
  55          2:ç¨‹åºæ­£å¸¸åˆå§‹åŒ–å®Œæˆå,å»ºè®®ä¸è¿›è¡Œå…³ä¸²å£ä¸­æ–­,å¦‚å¿…é¡»å…³ä¸­æ–­,å…³ä¸­æ–­æ—¶é—´å¿…é¡»çŸ
             -­,å…³ä¸­æ–­ä¼šå¼•èµ·ä¸²å£æ•°æ®åŒ…ä¸¢å¤±
  56          3:è¯·å‹¿åœ¨ä¸­æ–­/å®šæ—¶å™¨ä¸­æ–­å†…è°ƒç”¨ä¸ŠæŠ¥å‡½æ•°
  57          ******************************************************************************/
  58          /******************************************************************************
  59                                        ç¬¬ä¸€æ­¥:åˆå§‹åŒ–
  60          1:åœ¨éœ€è¦ä½¿ç”¨åˆ°zigbeeç›¸å…³æ–‡ä»¶çš„æ–‡ä»¶ä¸­include "zigbee.h"
  61          2:åœ¨MCUåˆå§‹åŒ–ä¸­è°ƒç”¨mcu_api.cæ–‡ä»¶ä¸­çš„zigbee_protocol_init()å‡½æ•°
  62          3:å°†MCUä¸²å£å•å­—èŠ‚å‘é€å‡½æ•°å¡«å…¥protocol.cæ–‡ä»¶ä¸­uart_transmit_outputå‡½æ•°å†…,å¹¶åˆ é™¤#error
  63          4:åœ¨MCUä¸²å£æ¥æ”¶å‡½æ•°ä¸­è°ƒç”¨mcu_api.cæ–‡ä»¶å†…çš„uart_receive_inputå‡½æ•°,å¹¶å°†æ¥æ”¶åˆ°çš„å­—èŠ‚ä
             -½œä¸ºå‚æ•°ä¼ å…¥
  64          5:å•ç‰‡æœºè¿›å…¥whileå¾ªç¯åè°ƒç”¨mcu_api.cæ–‡ä»¶å†…çš„zigbee_uart_service()å‡½æ•°
  65          ******************************************************************************/
  66          
  67          /******************************************************************************
  68                                  1:dpæ•°æ®ç‚¹åºåˆ—ç±»å‹å¯¹ç…§è¡¨
  69                    **æ­¤ä¸ºè‡ªåŠ¨ç”Ÿæˆä»£ç ,å¦‚åœ¨å¼€å‘å¹³å°æœ‰ç›¸å…³ä¿®æ”¹è¯·é‡æ–°ä¸‹è½½MCU_SDK**         
  70          ******************************************************************************/
  71          
  72          ///> dp data list, this will be generated by cloud platform
  73          const DOWNLOAD_CMD_S xdata download_cmd[] =
  74          {
  75            {DPID_SWITCH_LED, DP_TYPE_BOOL},
  76            {DPID_BRIGHT_VALUE, DP_TYPE_VALUE},
  77            {DPID_CDS, DP_TYPE_ENUM},
  78            {DPID_PIR_DELAY, DP_TYPE_VALUE},
  79            {DPID_SWITCH_XBR, DP_TYPE_BOOL},
  80            {DPID_STANDBY_TIME, DP_TYPE_VALUE},
  81            {DPID_SENSE_STRESS, DP_TYPE_VALUE},
  82            {DPID_SWITCH_LED2, DP_TYPE_BOOL},
  83            {DPID_SWITCH_LINKAGE, DP_TYPE_BOOL},
  84            {DPID_ALL_DAY_MICRO_LIGHT, DP_TYPE_BOOL},
  85            {DPID_RADAR_TRIGGER_TIMES, DP_TYPE_VALUE},
  86            {DPID_CLEAR_TRIGGER_NUMBER, DP_TYPE_BOOL},
  87            {DPID_LIGHT_STATUS, DP_TYPE_ENUM},
  88            {DPID_PERSON_IN_RANGE, DP_TYPE_ENUM},
  89          };
  90          
  91          
  92          /******************************************************************************
  93                                     2:ä¸²å£å•å­—èŠ‚å‘é€å‡½æ•°
  94          è¯·å°†MCUä¸²å£å‘é€å‡½æ•°å¡«å…¥è¯¥å‡½æ•°å†…,å¹¶å°†æ¥æ”¶åˆ°çš„æ•°æ®ä½œä¸ºå‚æ•°ä¼ å…¥ä¸²å£å‘é€å‡½æ•°
  95          ******************************************************************************/
  96          
  97          static void report_mcu_ota_result(unsigned char  res);
  98          
  99          
 100          /**
 101          * @brief encapsulates a generic send function, developer should use their own function to completing this 
             -fuction 
 102          * @param[in] {value} send signle data 
 103          * @return  void
 104          */
 105          void uart_transmit_output(unsigned char value)
 106          {
 107   1      // #error "è¯·å°†MCUä¸²å£å‘é€å‡½æ•°å¡«å…¥è¯¥å‡½æ•°,å¹¶åˆ é™¤è¯¥è¡Œ"
 108   1          send_data(value);
 109   1        
 110   1      /*
 111   1        //ç¤ºä¾‹:
 112   1        extern void Uart_PutChar(unsigned char value);
C51 COMPILER V9.52.0.0   PROTOCOL                                                          01/18/2021 13:48:16 PAGE 3   

 113   1        Uart_PutChar(value);                                  //ä¸²å£å‘é€å‡½æ•°
 114   1      */
 115   1      }
 116          
 117          /******************************************************************************
 118                                     ç¬¬äºŒæ­¥:å®ç°å…·ä½“ç”¨æˆ·å‡½æ•°
 119          1:APPä¸‹å‘æ•°æ®å¤„ç†
 120          2:æ•°æ®ä¸ŠæŠ¥å¤„ç†
 121          ******************************************************************************/
 122          
 123          /******************************************************************************
 124                                      1:æ‰€æœ‰æ•°æ®ä¸ŠæŠ¥å¤„ç†
 125          å½“å‰å‡½æ•°å¤„ç†å…¨éƒ¨æ•°æ®ä¸ŠæŠ¥(åŒ…æ‹¬å¯ä¸‹å‘/å¯ä¸ŠæŠ¥å’Œåªä¸ŠæŠ¥)
 126            éœ€è¦ç”¨æˆ·æŒ‰ç…§å®é™…æƒ…å†µå®ç°:
 127            1:éœ€è¦å®ç°å¯ä¸‹å‘/å¯ä¸ŠæŠ¥æ•°æ®ç‚¹ä¸ŠæŠ¥
 128            2:éœ€è¦å®ç°åªä¸ŠæŠ¥æ•°æ®ç‚¹ä¸ŠæŠ¥
 129          æ­¤å‡½æ•°ä¸ºMCUå†…éƒ¨å¿…é¡»è°ƒç”¨
 130          ç”¨æˆ·ä¹Ÿå¯è°ƒç”¨æ­¤å‡½æ•°å®ç°å…¨éƒ¨æ•°æ®ä¸ŠæŠ¥
 131          ******************************************************************************/
 132          
 133          //è‡ªåŠ¨åŒ–ç”Ÿæˆæ•°æ®ä¸ŠæŠ¥å‡½æ•°
 134          
 135          /**
 136          * @brief Upload all dp information of the system, and realize the synchronization of APP and muc data
 137          * @param[in] {void}
 138          * @return  void
 139          */
 140          void all_data_update(void)
 141          {
 142   1        //do nothing
 143   1      }
 144          
 145          /******************************************************************************
 146                                          WARNING!!!    
 147                                      2:æ‰€æœ‰æ•°æ®ä¸ŠæŠ¥å¤„ç†
 148          è‡ªåŠ¨åŒ–ä»£ç æ¨¡æ¿å‡½æ•°,å…·ä½“è¯·ç”¨æˆ·è‡ªè¡Œå®ç°æ•°æ®å¤„ç†
 149          ******************************************************************************/
 150          
 151          ///> this will realize by  cloud platform
 152          
 153          /*****************************************************************************
 154          å‡½æ•°åç§° : dp_download_switch_led_handle
 155          åŠŸèƒ½æè¿° : é’ˆå¯¹DPID_SWITCH_LEDçš„å¤„ç†å‡½æ•°
 156          è¾“å…¥å‚æ•° : value:æ•°æ®æºæ•°æ®
 157                  : length:æ•°æ®é•¿åº¦
 158          è¿”å›å‚æ•° : æˆåŠŸè¿”å›:SUCCESS/å¤±è´¥è¿”å›:ERROR
 159          ä½¿ç”¨è¯´æ˜ : å¯ä¸‹å‘å¯ä¸ŠæŠ¥ç±»å‹,éœ€è¦åœ¨å¤„ç†å®Œæ•°æ®åä¸ŠæŠ¥å¤„ç†ç»“æœè‡³app
 160          *****************************************************************************/
 161          static unsigned char dp_download_switch_led_handle(const unsigned char value[], unsigned short length)
 162          {
 163   1          //ç¤ºä¾‹:å½“å‰DPç±»å‹ä¸ºBOOL
 164   1          unsigned char ret;
 165   1          //0:å…³/1:å¼€
 166   1          unsigned char switch_led;
 167   1          
 168   1          switch_led = mcu_get_dp_download_bool(value,length);
 169   1      
 170   1          reset_bt_bn = switch_led;
 171   1        
 172   1          
 173   1          //å¤„ç†å®ŒDPæ•°æ®ååº”æœ‰åé¦ˆ
 174   1          ret = mcu_dp_bool_update(DPID_SWITCH_LED, reset_bt_bn);
C51 COMPILER V9.52.0.0   PROTOCOL                                                          01/18/2021 13:48:16 PAGE 4   

 175   1          if(ret == SUCCESS)
 176   1              return SUCCESS;
 177   1          else
 178   1              return ERROR;
 179   1      }
 180          /*****************************************************************************
 181          å‡½æ•°åç§° : dp_download_bright_value_handle
 182          åŠŸèƒ½æè¿° : é’ˆå¯¹DPID_BRIGHT_VALUEçš„å¤„ç†å‡½æ•°
 183          è¾“å…¥å‚æ•° : value:æ•°æ®æºæ•°æ®
 184                  : length:æ•°æ®é•¿åº¦
 185          è¿”å›å‚æ•° : æˆåŠŸè¿”å›:SUCCESS/å¤±è´¥è¿”å›:ERROR
 186          ä½¿ç”¨è¯´æ˜ : å¯ä¸‹å‘å¯ä¸ŠæŠ¥ç±»å‹,éœ€è¦åœ¨å¤„ç†å®Œæ•°æ®åä¸ŠæŠ¥å¤„ç†ç»“æœè‡³app
 187          *****************************************************************************/
 188          static unsigned char dp_download_bright_value_handle(const unsigned char value[], unsigned short length)
 189          {
 190   1          //ç¤ºä¾‹:å½“å‰DPç±»å‹ä¸ºVALUE
 191   1          unsigned char ret;
 192   1          unsigned long bright_value;
 193   1          unsigned char i;
 194   1          
 195   1          bright_value = mcu_get_dp_download_value(value,length);
 196   1        
 197   1        //DPID_BRIGHT_VALUEcount++;
 198   1        if(bright_value==lightvalue)
 199   1        {
 200   2      /*    if(DPID_BRIGHT_VALUEcount<2)
 201   2          {
 202   2            //DPID_BRIGHT_VALUEcount = 0;
 203   2            
 204   2            for(i=0;i<8;i++)
 205   2            {
 206   2              if(groupaddr[i] != 0)
 207   2              {
 208   2                mcu_dp_value_mesh_update(DPID_BRIGHT_VALUE,bright_value,groupaddr[i]);
 209   2              }
 210   2            }
 211   2          } */
 212   2        }
 213   1        else
 214   1        {
 215   2          //DPID_BRIGHT_VALUEcount=0;
 216   2          for(i=0;i<8;i++)
 217   2          {
 218   3      //      if(groupaddr[i] != 0)
 219   3      //      {
 220   3      //        mcu_dp_value_mesh_update(DPID_BRIGHT_VALUE,bright_value,groupaddr[i]);
 221   3      //      }
 222   3          }
 223   2        } 
 224   1        
 225   1          lightvalue = bright_value;
 226   1      
 227   1        //if(SWITCHfXBR==0)
 228   1        {
 229   2          XRBoffbrightvalue = bright_value;
 230   2        }
 231   1        
 232   1        savevar();
 233   1          
 234   1          //å¤„ç†å®ŒDPæ•°æ®ååº”æœ‰åé¦ˆ
 235   1          ret = mcu_dp_value_update(DPID_BRIGHT_VALUE, lightvalue);
 236   1      
C51 COMPILER V9.52.0.0   PROTOCOL                                                          01/18/2021 13:48:16 PAGE 5   

 237   1          if(ret == SUCCESS)
 238   1              return SUCCESS;
 239   1          else
 240   1              return ERROR;
 241   1      }
 242          /*****************************************************************************
 243          å‡½æ•°åç§° : dp_download_cds_handle
 244          åŠŸèƒ½æè¿° : é’ˆå¯¹DPID_CDSçš„å¤„ç†å‡½æ•°
 245          è¾“å…¥å‚æ•° : value:æ•°æ®æºæ•°æ®
 246                  : length:æ•°æ®é•¿åº¦
 247          è¿”å›å‚æ•° : æˆåŠŸè¿”å›:SUCCESS/å¤±è´¥è¿”å›:ERROR
 248          ä½¿ç”¨è¯´æ˜ : å¯ä¸‹å‘å¯ä¸ŠæŠ¥ç±»å‹,éœ€è¦åœ¨å¤„ç†å®Œæ•°æ®åä¸ŠæŠ¥å¤„ç†ç»“æœè‡³app
 249          *****************************************************************************/
 250          static unsigned char dp_download_cds_handle(const unsigned char value[], unsigned short length)
 251          {
 252   1          //ç¤ºä¾‹:å½“å‰DPç±»å‹ä¸ºENUM
 253   1          unsigned char ret;
 254   1          unsigned char cds;
 255   1          unsigned char i;
 256   1          
 257   1          cds = mcu_get_dp_download_enum(value,length);
 258   1        
 259   1        //DPID_CDScount++;
 260   1        if(cds==cdsvalue)
 261   1        {
 262   2          //if(DPID_CDScount<2)
 263   2          {
 264   3      /*      for(i=0;i<8;i++)
 265   3            {
 266   3              if(groupaddr[i] != 0)
 267   3              {
 268   3                mcu_dp_enum_mesh_update(DPID_CDS,cds,groupaddr[i]);
 269   3              }
 270   3            } */
 271   3          }
 272   2          if((cds==5)&&(light_ad!=LIGHT_TH))
 273   2          {
 274   3            //DPID_CDScount=0;
 275   3          }
 276   2        }
 277   1        else
 278   1        {
 279   2          //DPID_CDScount=0;
 280   2          for(i=0;i<8;i++)
 281   2          {
 282   3      //      if(groupaddr[i] != 0)
 283   3      //      {
 284   3      //        mcu_dp_enum_mesh_update(DPID_CDS,cds,groupaddr[i]);
 285   3      //      }
 286   3          }
 287   2        } 
 288   1        
 289   1          switch(cds) {
 290   2              case 0:   //2000LUS
 291   2            LIGHT_TH=255;//cds*4;
 292   2              break;
 293   2              
 294   2              case 1:   //300LUX
 295   2            LIGHT_TH=255;//cds*4;
 296   2              break;
 297   2              
 298   2              case 2:   //50LUX
C51 COMPILER V9.52.0.0   PROTOCOL                                                          01/18/2021 13:48:16 PAGE 6   

 299   2            LIGHT_TH=200;
 300   2              break;
 301   2              
 302   2              case 3: //10LUX
 303   2            LIGHT_TH=40;
 304   2              break;
 305   2              
 306   2              case 4: //5LUX
 307   2            LIGHT_TH=20;
 308   2              break;
 309   2              
 310   2          case 5:
 311   2            LIGHT_TH = light_ad;
 312   2          break;
 313   2              
 314   2              default:
 315   2          
 316   2              break;
 317   2          }
 318   1      
 319   1          cdsvalue = cds;
 320   1      
 321   1          savevar();
 322   1          //sprintf(temp_str, "%3d", LIGHT_TH);
 323   1          //mcu_dp_string_update(DPID_DEBUG, temp_str, strlen(temp_str));
 324   1          //å¤„ç†å®ŒDPæ•°æ®ååº”æœ‰åé¦ˆ
 325   1          ret = mcu_dp_enum_update(DPID_CDS, cdsvalue);
 326   1          if(ret == SUCCESS)
 327   1              return SUCCESS;
 328   1          else
 329   1              return ERROR;
 330   1      }
 331          /*****************************************************************************
 332          å‡½æ•°åç§° : dp_download_pir_delay_handle
 333          åŠŸèƒ½æè¿° : é’ˆå¯¹DPID_PIR_DELAYçš„å¤„ç†å‡½æ•°
 334          è¾“å…¥å‚æ•° : value:æ•°æ®æºæ•°æ®
 335                  : length:æ•°æ®é•¿åº¦
 336          è¿”å›å‚æ•° : æˆåŠŸè¿”å›:SUCCESS/å¤±è´¥è¿”å›:ERROR
 337          ä½¿ç”¨è¯´æ˜ : å¯ä¸‹å‘å¯ä¸ŠæŠ¥ç±»å‹,éœ€è¦åœ¨å¤„ç†å®Œæ•°æ®åä¸ŠæŠ¥å¤„ç†ç»“æœè‡³app
 338          *****************************************************************************/
 339          static unsigned char dp_download_pir_delay_handle(const unsigned char value[], unsigned short length)
 340          {
 341   1          //ç¤ºä¾‹:å½“å‰DPç±»å‹ä¸ºVALUE
 342   1          unsigned char ret;
 343   1          unsigned long pir_delay;
 344   1          unsigned char i;
 345   1          
 346   1          pir_delay = mcu_get_dp_download_value(value,length);
 347   1          /*
 348   1          //VALUEç±»å‹æ•°æ®å¤„ç†
 349   1          */
 350   1        
 351   1        //DPID_PIR_DELAYcount++;
 352   1        if(pir_delay==DELAY_NUM)
 353   1        {
 354   2      /*    if(DPID_PIR_DELAYcount<2)
 355   2          {
 356   2            for(i=0;i<8;i++)
 357   2            {
 358   2              if(groupaddr[i] != 0)
 359   2              {
 360   2                mcu_dp_value_mesh_update(DPID_PIR_DELAY,pir_delay,groupaddr[i]);
C51 COMPILER V9.52.0.0   PROTOCOL                                                          01/18/2021 13:48:16 PAGE 7   

 361   2              }
 362   2            }
 363   2          } */
 364   2        }
 365   1        else
 366   1        {
 367   2          //DPID_PIR_DELAYcount=0;
 368   2          for(i=0;i<8;i++)
 369   2          {
 370   3      //      if(groupaddr[i] != 0)
 371   3      //      {
 372   3      //        mcu_dp_value_mesh_update(DPID_PIR_DELAY,pir_delay,groupaddr[i]);
 373   3      //      }
 374   3          }
 375   2        }
 376   1        
 377   1          DELAY_NUM = pir_delay;
 378   1        savevar();
 379   1          
 380   1          //å¤„ç†å®ŒDPæ•°æ®ååº”æœ‰åé¦ˆ
 381   1          ret = mcu_dp_value_update(DPID_PIR_DELAY, DELAY_NUM);
 382   1          if(ret == SUCCESS)
 383   1              return SUCCESS;
 384   1          else
 385   1              return ERROR;
 386   1      }
 387          /*****************************************************************************
 388          å‡½æ•°åç§° : dp_download_switch_xbr_handle
 389          åŠŸèƒ½æè¿° : é’ˆå¯¹DPID_SWITCH_XBRçš„å¤„ç†å‡½æ•°
 390          è¾“å…¥å‚æ•° : value:æ•°æ®æºæ•°æ®
 391                  : length:æ•°æ®é•¿åº¦
 392          è¿”å›å‚æ•° : æˆåŠŸè¿”å›:SUCCESS/å¤±è´¥è¿”å›:ERROR
 393          ä½¿ç”¨è¯´æ˜ : å¯ä¸‹å‘å¯ä¸ŠæŠ¥ç±»å‹,éœ€è¦åœ¨å¤„ç†å®Œæ•°æ®åä¸ŠæŠ¥å¤„ç†ç»“æœè‡³app
 394          *****************************************************************************/
 395          static unsigned char dp_download_switch_xbr_handle(const unsigned char value[], unsigned short length)
 396          {
 397   1          //ç¤ºä¾‹:å½“å‰DPç±»å‹ä¸ºBOOL
 398   1          unsigned char ret;
 399   1          //0:å…³/1:å¼€
 400   1          unsigned char switch_xbr;
 401   1          unsigned char i;
 402   1          
 403   1          switch_xbr = mcu_get_dp_download_bool(value,length);
 404   1        
 405   1        //DPID_SWITCH_XBRcount++;
 406   1        if(switch_xbr==SWITCHfXBR)
 407   1        {
 408   2      /*    if(DPID_SWITCH_XBRcount<2)
 409   2          {
 410   2            for(i=0;i<8;i++)
 411   2            {
 412   2              if(groupaddr[i] != 0)
 413   2              {
 414   2                mcu_dp_bool_mesh_update(DPID_SWITCH_XBR,switch_xbr,groupaddr[i]);
 415   2              }
 416   2            }
 417   2          } */
 418   2        }
 419   1        else
 420   1        {
 421   2          //DPID_SWITCH_XBRcount=0;
 422   2          for(i=0;i<8;i++)
C51 COMPILER V9.52.0.0   PROTOCOL                                                          01/18/2021 13:48:16 PAGE 8   

 423   2          {
 424   3      //      if(groupaddr[i] != 0)
 425   3      //      {
 426   3      //        mcu_dp_bool_mesh_update(DPID_SWITCH_XBR,switch_xbr,groupaddr[i]);
 427   3      //      }
 428   3          }
 429   2        
 430   2        }
 431   1        
 432   1          if(switch_xbr == 0) {
 433   2              //å¼€å…³å…³
 434   2              SWITCHfXBR = 0;
 435   2              //mcu_dp_string_update(DPID_DEBUG, radar_bn_off, strlen(radar_bn_off));
 436   2          }else {
 437   2              //å¼€å…³å¼€
 438   2              SWITCHfXBR = 1;
 439   2              //mcu_dp_string_update(DPID_DEBUG, radar_bn_on, strlen(radar_bn_on));
 440   2          }
 441   1        
 442   1          savevar();
 443   1          //å¤„ç†å®ŒDPæ•°æ®ååº”æœ‰åé¦ˆ
 444   1          ret = mcu_dp_bool_update(DPID_SWITCH_XBR,SWITCHfXBR);
 445   1          if(ret == SUCCESS)
 446   1              return SUCCESS;
 447   1          else
 448   1              return ERROR;
 449   1      }
 450          /*****************************************************************************
 451          å‡½æ•°åç§° : dp_download_standby_time_handle
 452          åŠŸèƒ½æè¿° : é’ˆå¯¹DPID_STANDBY_TIMEçš„å¤„ç†å‡½æ•°
 453          è¾“å…¥å‚æ•° : value:æ•°æ®æºæ•°æ®
 454                  : length:æ•°æ®é•¿åº¦
 455          è¿”å›å‚æ•° : æˆåŠŸè¿”å›:SUCCESS/å¤±è´¥è¿”å›:ERROR
 456          ä½¿ç”¨è¯´æ˜ : å¯ä¸‹å‘å¯ä¸ŠæŠ¥ç±»å‹,éœ€è¦åœ¨å¤„ç†å®Œæ•°æ®åä¸ŠæŠ¥å¤„ç†ç»“æœè‡³app
 457          *****************************************************************************/
 458          static unsigned char dp_download_standby_time_handle(const unsigned char value[], unsigned short length)
 459          {
 460   1          //ç¤ºä¾‹:å½“å‰DPç±»å‹ä¸ºVALUE
 461   1          unsigned char ret;
 462   1          unsigned long standby_time;
 463   1          unsigned char i;
 464   1          
 465   1          standby_time = mcu_get_dp_download_value(value,length);
 466   1          /*
 467   1          //VALUEç±»å‹æ•°æ®å¤„ç†
 468   1          
 469   1          */
 470   1        //DPID_STANDBY_TIMEcount++;
 471   1        if(standby_time==lowlightDELAY_NUM)
 472   1        {
 473   2      /*    if(DPID_STANDBY_TIMEcount<2)
 474   2          {
 475   2            for(i=0;i<8;i++)
 476   2            {
 477   2              if(groupaddr[i] != 0)
 478   2              {
 479   2                mcu_dp_value_mesh_update(DPID_STANDBY_TIME,standby_time,groupaddr[i]);
 480   2              }
 481   2            }
 482   2          } */
 483   2        }
 484   1        else
C51 COMPILER V9.52.0.0   PROTOCOL                                                          01/18/2021 13:48:16 PAGE 9   

 485   1        {
 486   2          //DPID_STANDBY_TIMEcount=0;
 487   2          for(i=0;i<8;i++)
 488   2            {
 489   3      //        if(groupaddr[i] != 0)
 490   3      //        {
 491   3      //          mcu_dp_value_mesh_update(DPID_STANDBY_TIME,standby_time,groupaddr[i]);
 492   3      //        }
 493   3            }
 494   2        
 495   2        }
 496   1        
 497   1          lowlightDELAY_NUM=standby_time;
 498   1          
 499   1          savevar();
 500   1          //å¤„ç†å®ŒDPæ•°æ®ååº”æœ‰åé¦ˆ
 501   1          ret = mcu_dp_value_update(DPID_STANDBY_TIME, lowlightDELAY_NUM);
 502   1          if(ret == SUCCESS)
 503   1              return SUCCESS;
 504   1          else
 505   1              return ERROR;
 506   1      }
 507          /*****************************************************************************
 508          å‡½æ•°åç§° : dp_download_sense_stress_handle
 509          åŠŸèƒ½æè¿° : é’ˆå¯¹DPID_SENSE_STRESSçš„å¤„ç†å‡½æ•°
 510          è¾“å…¥å‚æ•° : value:æ•°æ®æºæ•°æ®
 511                  : length:æ•°æ®é•¿åº¦
 512          è¿”å›å‚æ•° : æˆåŠŸè¿”å›:SUCCESS/å¤±è´¥è¿”å›:ERROR
 513          ä½¿ç”¨è¯´æ˜ : å¯ä¸‹å‘å¯ä¸ŠæŠ¥ç±»å‹,éœ€è¦åœ¨å¤„ç†å®Œæ•°æ®åä¸ŠæŠ¥å¤„ç†ç»“æœè‡³app
 514          *****************************************************************************/
 515          static unsigned char dp_download_sense_stress_handle(const unsigned char value[], unsigned short length)
 516          {
 517   1          //ç¤ºä¾‹:å½“å‰DPç±»å‹ä¸ºVALUE
 518   1          unsigned char ret;
 519   1          unsigned long sense_stress;
 520   1          unsigned char i;
 521   1          
 522   1          sense_stress = mcu_get_dp_download_value(value,length);
 523   1          /*
 524   1          //VALUEç±»å‹æ•°æ®å¤„ç†
 525   1          
 526   1          */
 527   1        //DPID_SENSE_STRESScount++;
 528   1        if(sense_stress==sensing_th)
 529   1        {
 530   2      /*    if(DPID_SENSE_STRESScount<2)
 531   2          {
 532   2            for(i=0;i<8;i++)
 533   2            {
 534   2              if(groupaddr[i] != 0)
 535   2              {
 536   2                mcu_dp_value_mesh_update(DPID_SENSE_STRESS,sense_stress,groupaddr[i]);
 537   2              }
 538   2            }
 539   2          } */
 540   2        }
 541   1        else
 542   1        {
 543   2          //DPID_SENSE_STRESScount=0;
 544   2          for(i=0;i<8;i++)
 545   2          {
 546   3      //      if(groupaddr[i] != 0)
C51 COMPILER V9.52.0.0   PROTOCOL                                                          01/18/2021 13:48:16 PAGE 10  

 547   3      //      {
 548   3      //        mcu_dp_value_mesh_update(DPID_SENSE_STRESS,sense_stress,groupaddr[i]);
 549   3      //      }
 550   3          }
 551   2        } 
 552   1        
 553   1        sensing_th = sense_stress;
 554   1        TH=(50-sense_stress)*10000;
 555   1          
 556   1        savevar();
 557   1          
 558   1          //sprintf(temp_str, "%6d", TH);
 559   1          //mcu_dp_string_update(DPID_DEBUG, temp_str, strlen(temp_str));    
 560   1          //å¤„ç†å®ŒDPæ•°æ®ååº”æœ‰åé¦ˆ
 561   1          ret = mcu_dp_value_update(DPID_SENSE_STRESS, sensing_th);
 562   1          if(ret == SUCCESS)
 563   1              return SUCCESS;
 564   1          else
 565   1              return ERROR;
 566   1      }
 567          /*****************************************************************************
 568          å‡½æ•°åç§° : dp_download_switch_led2_handle
 569          åŠŸèƒ½æè¿° : é’ˆå¯¹DPID_SWITCH_LED2çš„å¤„ç†å‡½æ•°
 570          è¾“å…¥å‚æ•° : value:æ•°æ®æºæ•°æ®
 571                  : length:æ•°æ®é•¿åº¦
 572          è¿”å›å‚æ•° : æˆåŠŸè¿”å›:SUCCESS/å¤±è´¥è¿”å›:ERROR
 573          ä½¿ç”¨è¯´æ˜ : å¯ä¸‹å‘å¯ä¸ŠæŠ¥ç±»å‹,éœ€è¦åœ¨å¤„ç†å®Œæ•°æ®åä¸ŠæŠ¥å¤„ç†ç»“æœè‡³app
 574          *****************************************************************************/
 575          static unsigned char dp_download_switch_led2_handle(const unsigned char value[], unsigned short length)
 576          {
 577   1          //ç¤ºä¾‹:å½“å‰DPç±»å‹ä¸ºBOOL
 578   1          unsigned char ret;
 579   1          //0:å…³/1:å¼€
 580   1          unsigned char switch_led2;
 581   1          unsigned char i;
 582   1          
 583   1          switch_led2 = mcu_get_dp_download_bool(value,length);
 584   1      
 585   1          //DPID_SWITCH_LED2count++;
 586   1          if(switch_led2==SWITCHflag2)
 587   1          {
 588   2      /*      if(DPID_SWITCH_LED2count<2)
 589   2            {
 590   2              for(i=0;i<8;i++)
 591   2              {
 592   2                if(groupaddr[i] != 0)
 593   2                {
 594   2                  mcu_dp_bool_mesh_update(DPID_SWITCH_LED2,switch_led2,groupaddr[i]);
 595   2                }
 596   2              }
 597   2            } */
 598   2          }
 599   1          else
 600   1          {
 601   2            //DPID_SWITCH_LED2count=0;
 602   2            for(i=0;i<8;i++)
 603   2            {
 604   3      //        if(groupaddr[i] != 0)
 605   3      //        {
 606   3      //          mcu_dp_bool_mesh_update(DPID_SWITCH_LED2,switch_led2,groupaddr[i]);
 607   3      //        }
 608   3            }   
C51 COMPILER V9.52.0.0   PROTOCOL                                                          01/18/2021 13:48:16 PAGE 11  

 609   2      
 610   2          }
 611   1      
 612   1          if(switch_led2 == 0) {
 613   2              //ç¯å¼€å…³å…³
 614   2              SWITCHflag2=0;
 615   2          }else {
 616   2              //ç¯å¼€å…³å¼€
 617   2              //mcu_dp_string_update(DPID_DEBUG, led_bn_on, strlen(led_bn_on));
 618   2              if(SWITCHfXBR==1)
 619   2          {
 620   3            Light_on_flag=1;
 621   3          }
 622   2              SWITCHflag2=1;
 623   2          }
 624   1        
 625   1          //å¤„ç†å®ŒDPæ•°æ®ååº”æœ‰åé¦ˆ
 626   1          ret = mcu_dp_bool_update(DPID_SWITCH_LED2, SWITCHflag2);
 627   1          if(ret == SUCCESS)
 628   1              return SUCCESS;
 629   1          else
 630   1              return ERROR;
 631   1      }
 632          /*****************************************************************************
 633          å‡½æ•°åç§° : dp_download_switch_linkage_handle
 634          åŠŸèƒ½æè¿° : é’ˆå¯¹DPID_SWITCH_LINKAGEçš„å¤„ç†å‡½æ•°
 635          è¾“å…¥å‚æ•° : value:æ•°æ®æºæ•°æ®
 636                  : length:æ•°æ®é•¿åº¦
 637          è¿”å›å‚æ•° : æˆåŠŸè¿”å›:SUCCESS/å¤±è´¥è¿”å›:ERROR
 638          ä½¿ç”¨è¯´æ˜ : å¯ä¸‹å‘å¯ä¸ŠæŠ¥ç±»å‹,éœ€è¦åœ¨å¤„ç†å®Œæ•°æ®åä¸ŠæŠ¥å¤„ç†ç»“æœè‡³app
 639          *****************************************************************************/
 640          static unsigned char dp_download_switch_linkage_handle(const unsigned char value[], unsigned short length)
 641          {
 642   1          //ç¤ºä¾‹:å½“å‰DPç±»å‹ä¸ºBOOL
 643   1          unsigned char ret;
 644   1          //0:å…³/1:å¼€
 645   1          unsigned char switch_Linkage;
 646   1          unsigned char i;
 647   1          switch_Linkage = mcu_get_dp_download_bool(value,length);
 648   1          
 649   1        if(switch_Linkage==Linkage_flag)
 650   1        {
 651   2          //
 652   2        }
 653   1        else
 654   1        {
 655   2          for(i=0;i<8;i++)
 656   2          {
 657   3      //      if(groupaddr[i] != 0)
 658   3      //      {
 659   3      //        mcu_dp_bool_mesh_update(DPID_SWITCH_LINKAGE,switch_Linkage,groupaddr[i]);
 660   3      //      }
 661   3          }
 662   2        }
 663   1          if(switch_Linkage == 0) {
 664   2              //é›·è¾¾å¼€å…³å…³
 665   2              //LIGHT_OFF;
 666   2              //PWM3init(0);
 667   2              Linkage_flag=0;
 668   2          }else {
 669   2              //é›·è¾¾å¼€å…³å¼€
 670   2              //LIGHT_ON;
C51 COMPILER V9.52.0.0   PROTOCOL                                                          01/18/2021 13:48:16 PAGE 12  

 671   2              //PWM3init(100);
 672   2              Linkage_flag=1;
 673   2          }
 674   1          
 675   1          //å¤„ç†å®ŒDPæ•°æ®ååº”æœ‰åé¦ˆ
 676   1          ret = mcu_dp_bool_update(DPID_SWITCH_LINKAGE,switch_Linkage);
 677   1          if(ret == SUCCESS)
 678   1              return SUCCESS;
 679   1          else
 680   1              return ERROR;
 681   1      
 682   1      }
 683          /*****************************************************************************
 684          å‡½æ•°åç§° : dp_download_all_day_micro_light_handle
 685          åŠŸèƒ½æè¿° : é’ˆå¯¹DPID_ALL_DAY_MICRO_LIGHTçš„å¤„ç†å‡½æ•°
 686          è¾“å…¥å‚æ•° : value:æ•°æ®æºæ•°æ®
 687                  : length:æ•°æ®é•¿åº¦
 688          è¿”å›å‚æ•° : æˆåŠŸè¿”å›:SUCCESS/å¤±è´¥è¿”å›:ERROR
 689          ä½¿ç”¨è¯´æ˜ : å¯ä¸‹å‘å¯ä¸ŠæŠ¥ç±»å‹,éœ€è¦åœ¨å¤„ç†å®Œæ•°æ®åä¸ŠæŠ¥å¤„ç†ç»“æœè‡³app
 690          *****************************************************************************/
 691          static unsigned char dp_download_all_day_micro_light_handle(const unsigned char value[], unsigned short le
             -ngth)
 692          {
 693   1          //ç¤ºä¾‹:å½“å‰DPç±»å‹ä¸ºBOOL
 694   1          unsigned char ret;
 695   1          //0:å…³/1:å¼€
 696   1          unsigned char all_day_micro_light;
 697   1          u8 i;
 698   1          
 699   1          all_day_micro_light = mcu_get_dp_download_bool(value,length);
 700   1        
 701   1          if(all_day_micro_light_enable == all_day_micro_light)
 702   1          {
 703   2          //
 704   2          }
 705   1          else
 706   1          {
 707   2            for(i=0;i<8;i++)
 708   2            {
 709   3              //if(groupaddr[i] != 0)
 710   3              //{
 711   3                //mcu_dp_bool_mesh_update(DPID_ALL_DAY_MICRO_LIGHT,all_day_micro_light,groupaddr[i]);
 712   3              //}
 713   3            }   
 714   2      
 715   2          }
 716   1        
 717   1        all_day_micro_light_enable = all_day_micro_light;
 718   1        
 719   1          //å¤„ç†å®ŒDPæ•°æ®ååº”æœ‰åé¦ˆ
 720   1          ret = mcu_dp_bool_update(DPID_ALL_DAY_MICRO_LIGHT, all_day_micro_light_enable);
 721   1          if(ret == SUCCESS)
 722   1              return SUCCESS;
 723   1          else
 724   1              return ERROR;
 725   1      
 726   1      }
 727          /*****************************************************************************
 728          å‡½æ•°åç§° : dp_download_clear_trigger_number_handle
 729          åŠŸèƒ½æè¿° : é’ˆå¯¹DPID_CLEAR_TRIGGER_NUMBERçš„å¤„ç†å‡½æ•°
 730          è¾“å…¥å‚æ•° : value:æ•°æ®æºæ•°æ®
 731                  : length:æ•°æ®é•¿åº¦
C51 COMPILER V9.52.0.0   PROTOCOL                                                          01/18/2021 13:48:16 PAGE 13  

 732          è¿”å›å‚æ•° : æˆåŠŸè¿”å›:SUCCESS/å¤±è´¥è¿”å›:ERROR
 733          ä½¿ç”¨è¯´æ˜ : åªä¸‹å‘ç±»å‹,éœ€è¦åœ¨å¤„ç†å®Œæ•°æ®åä¸ŠæŠ¥å¤„ç†ç»“æœè‡³app
 734          *****************************************************************************/
 735          static unsigned char dp_download_clear_trigger_number_handle(const unsigned char value[], unsigned short l
             -ength)
 736          {
 737   1          //ç¤ºä¾‹:å½“å‰DPç±»å‹ä¸ºBOOL
 738   1          //unsigned char ret;
 739   1          //0:å…³/1:å¼€
 740   1          unsigned char clear_trigger_number;
 741   1          
 742   1          clear_trigger_number = mcu_get_dp_download_bool(value,length);
 743   1          if(clear_trigger_number == 0) {
 744   2              //å¼€å…³å…³
 745   2          }else {
 746   2              //å¼€å…³å¼€
 747   2          radar_trig_times = 0;
 748   2          mcu_dp_value_update(DPID_RADAR_TRIGGER_TIMES,radar_trig_times); //VALUEå‹æ•°æ®ä¸ŠæŠ¥;
 749   2          }
 750   1        
 751   1          return SUCCESS;
 752   1      }
 753          
 754          
 755          
 756          
 757          #ifdef SUPPORT_MCU_RTC_CHECK
              /**
              * @brief mcu check local RTC time 
              * @param[in] {time} timestamp
              * @return  void
              */
              void mcu_write_rtctime(unsigned char time[])
              {
                #error "mcu should realize RTC time wtriting fuction, and delete this line"
                /*
                time[0]~time[3]ï¼šstandard time
                time[4]~time[7]: Local time
               */
                my_memcpy((void *)timestamp,(const char *)time,4);  //get timestamp
                zigbee_timestamp_to_time(); 
              /*
                year = _time.w_year;  //year
                month = _time.w_month;  //month
                date = _time.w_date;  //date
                hour = _time.hour + 8;  //hour(8:BeiJing time)
                min = _time.min;  //minute
                sec = _time.sec;  //second
              */
              }
              #endif
 782          
 783          
 784          /**
 785          * @brief Zigbee functional test feedback
 786          * @param[in] {void} 
 787          * @return  void
 788          */
 789          void zigbee_test_result(void)
 790          {
 791   1      //  #error "this test is makesure the rf fuction of zigbee module, if test pass or not should do something
             -, mcu should realize"
C51 COMPILER V9.52.0.0   PROTOCOL                                                          01/18/2021 13:48:16 PAGE 14  

 792   1        unsigned char rssi = zigbee_uart_rx_buf[DATA_START];
 793   1        
 794   1        if(rssi > 0x3C) {
 795   2          //test sucess the range of rssi is 0% ~ 100%
 796   2          //do some thing here!!!
 797   2          //
 798   2          //
 799   2          //
 800   2        }
 801   1        else{
 802   2          //test failure
 803   2        }
 804   1        
 805   1      }
 806          
 807          /******************************************************************************
 808                                          WARNING!!!                     
 809          ä»¥ä¸‹å‡½æ•°ç”¨æˆ·è¯·å‹¿ä¿®æ”¹!!
 810          ******************************************************************************/
 811          
 812          /**
 813          * @brief this function will handle uart received frame data  
 814          * @param[in] {dpid}   dp id
 815          * @param[in] {value}  dp data 
 816          * @param[in] {length} lenght of dp data 
 817          * @return  handle result 
 818          */
 819          unsigned char dp_download_handle(unsigned char dpid,const unsigned char value[], unsigned short length)
 820          {
 821   1        /* only list of function, mcu need realize these fuction*/
 822   1        unsigned char ret;
 823   1        switch(dpid){
 824   2                case DPID_SWITCH_LED:
 825   2                  //å¼€å…³å¤„ç†å‡½æ•°
 826   2                  ret = dp_download_switch_led_handle(value,length);
 827   2            if(ret==1)
 828   2            {
 829   3              switchcnt ++;
 830   3              if(switchcnt>=5)
 831   3              {
 832   4                switchcnt = 0;
 833   4                          reset_bt_module();
 834   4              }
 835   3            }
 836   2              break;
 837   2              case DPID_BRIGHT_VALUE:
 838   2                  //äº®åº¦å€¼å¤„ç†å‡½æ•°
 839   2                  ret = dp_download_bright_value_handle(value,length);
 840   2                  switchcnt = 0;
 841   2              break;
 842   2              case DPID_CDS:
 843   2                  //å…‰æ•å‚æ•°å¤„ç†å‡½æ•°
 844   2                  ret = dp_download_cds_handle(value,length);
 845   2                  switchcnt = 0;
 846   2              break;
 847   2              case DPID_PIR_DELAY:
 848   2                  //æ„Ÿåº”å»¶æ—¶å¤„ç†å‡½æ•°
 849   2                  ret = dp_download_pir_delay_handle(value,length);
 850   2                  switchcnt = 0;
 851   2              break;
 852   2              case DPID_SWITCH_XBR:
 853   2                  //é›·è¾¾å¼€å…³å¤„ç†å‡½æ•°
C51 COMPILER V9.52.0.0   PROTOCOL                                                          01/18/2021 13:48:16 PAGE 15  

 854   2                  ret = dp_download_switch_xbr_handle(value,length);
 855   2                  switchcnt = 0;
 856   2              break;
 857   2              case DPID_STANDBY_TIME:
 858   2                  //ä¼´äº®å»¶æ—¶å¤„ç†å‡½æ•°
 859   2                  ret = dp_download_standby_time_handle(value,length);
 860   2                  switchcnt = 0;
 861   2              break;
 862   2              case DPID_SENSE_STRESS:
 863   2                  //æ„Ÿåº”å¼ºåº¦å¤„ç†å‡½æ•°
 864   2                  ret = dp_download_sense_stress_handle(value,length);
 865   2                  switchcnt = 0;
 866   2              break;
 867   2              case DPID_SWITCH_LED2:
 868   2                  //å¼€å…³ç¯å¤„ç†å‡½æ•°
 869   2                  ret = dp_download_switch_led2_handle(value,length);
 870   2                  switchcnt = 0;
 871   2              break;
 872   2              case DPID_SWITCH_LINKAGE:
 873   2                  //è”åŠ¨å¤„ç†å‡½æ•°
 874   2                  ret = dp_download_switch_linkage_handle(value,length);
 875   2            switchcnt = 0;
 876   2              break;
 877   2              case DPID_ALL_DAY_MICRO_LIGHT:
 878   2                  //å…¨å¤©ä¼´äº®å¤„ç†å‡½æ•°
 879   2                  ret = dp_download_all_day_micro_light_handle(value,length);
 880   2            switchcnt = 0;
 881   2              break;
 882   2              case DPID_CLEAR_TRIGGER_NUMBER:
 883   2                  //è®¡æ•°æ¸…é›¶å¤„ç†å‡½æ•°
 884   2                  ret = dp_download_clear_trigger_number_handle(value,length);
 885   2            switchcnt = 0;
 886   2              break;
 887   2      
 888   2        default:
 889   2              switchcnt = 0;
 890   2          break;
 891   2        }
 892   1        return ret;
 893   1      }
 894          
 895          /**
 896          * @brief get received cmd total number
 897          * @param[in] {void}   
 898          * @return  received cmd total number
 899          */
 900          unsigned char get_download_cmd_total(void)
 901          {
 902   1        return(sizeof(download_cmd) / sizeof(download_cmd[0]));
 903   1      }
 904          
 905          
 906          /**
 907          * @brief received zigbee net_work state handle 
 908          * @param[in] {zigbee_work_state}  zigbee current network state
 909          * @return  void 
 910          */
 911          void zigbee_work_state_event(unsigned char zigbee_work_state)
 912          { 
 913   1        unsigned short length= 0;
 914   1        
 915   1        length = set_zigbee_uart_byte(length,0x10);
C51 COMPILER V9.52.0.0   PROTOCOL                                                          01/18/2021 13:48:16 PAGE 16  

 916   1        zigbee_uart_write_frame(ZIGBEE_STATE_CMD, length);  
 917   1      
 918   1        switch(zigbee_work_state){
 919   2          case ZIGBEE_NOT_JION: 
 920   2      
 921   2            break;
 922   2          
 923   2          case ZIGBEE_JOIN_GATEWAY: 
 924   2                all_data_update();
 925   2                savevar();
 926   2            break;
 927   2          
 928   2          case ZIGBEE_JOIN_ERROR: 
 929   2      
 930   2            break;
 931   2          
 932   2          case ZIGBEE_JOINING:  
 933   2      
 934   2            break;
 935   2          
 936   2          default:
 937   2            break;
 938   2        }
 939   1      }
 940          
 941          
 942          /**
 943          * @brief received reset zigbee response 
 944          * @param[in] {state} response state 
 945          * @return  void 
 946          */
 947          void mcu_reset_zigbee_event(unsigned char state)
 948          { 
 949   1        switch(state){
 950   2          case RESET_ZIGBEE_OK:
 951   2          
 952   2            break;
 953   2          
 954   2          case RESET_ZIGBEE_ERROR:
 955   2          
 956   2            break;
 957   2          
 958   2          default:
 959   2            break;
 960   2        }
 961   1      }
 962          
 963          
 964          /**
 965          * @brief check mcu version response
 966          * @param[in] {void}
 967          * @return  void 
 968          */
 969          void response_mcu_ota_version_event(void)
 970          {
 971   1        unsigned short length = 0;
 972   1        length = set_zigbee_uart_byte(length,get_current_mcu_fw_ver()); //current fw version
 973   1        zigbee_uart_write_frame(MCU_OTA_VERSION_CMD,length);
 974   1      }
 975          
 976          #ifdef SUPPORT_MCU_OTA
 977          /**
C51 COMPILER V9.52.0.0   PROTOCOL                                                          01/18/2021 13:48:16 PAGE 17  

 978          * @brief mcu ota update notify response
 979          * @param[in] {offset} data offset 
 980          * @return  void 
 981          */
 982          void response_mcu_ota_notify_event(unsigned char offset)
 983          {
 984   1        unsigned char i = 0;
 985   1        unsigned short length = 0;
 986   1        unsigned char result = 0;
 987   1        
 988   1        current_mcu_fw_pid(); //current PID
 989   1        
 990   1        while(i<8){
 991   2          ota_fw_info.mcu_ota_pid[i] = zigbee_uart_rx_buf[offset + DATA_START + i];               //ota fw PID
 992   2          i++;
 993   2        }
 994   1        ota_fw_info.mcu_ota_ver = zigbee_uart_rx_buf[offset + DATA_START + 8];                      //ota fw version
 995   1        ota_fw_info.mcu_ota_fw_size = zigbee_uart_rx_buf[offset + DATA_START + 9] << 24 | \
 996   1                                      zigbee_uart_rx_buf[offset +DATA_START + 10] << 16 | \
 997   1                                      zigbee_uart_rx_buf[offset + DATA_START + 11] << 8 | \
 998   1                                      zigbee_uart_rx_buf[offset + DATA_START + 12];               //ota fw size
 999   1        ota_fw_info.mcu_ota_checksum = zigbee_uart_rx_buf[offset + DATA_START + 13] << 24 | \
1000   1                                       zigbee_uart_rx_buf[offset + DATA_START + 14] << 16 | \
1001   1                                       zigbee_uart_rx_buf[offset + DATA_START + 15] << 8 | \
1002   1                                       zigbee_uart_rx_buf[offset + DATA_START + 16];                //ota fw checksum
1003   1        
1004   1        if((!strcmp_barry(&ota_fw_info.mcu_ota_pid[0],&current_mcu_pid[0])) && \
1005   1           (ota_fw_info.mcu_ota_ver > get_current_mcu_fw_ver() &&\
1006   1            ota_fw_info.mcu_ota_fw_size > 0)  
1007   1          ){    //check fw pid and fw version and fw size
1008   2          length = set_zigbee_uart_byte(length,0x00); //OK
1009   2          result = 1;
1010   2        }
1011   1        else{
1012   2          length = set_zigbee_uart_byte(length,0x01); //error
1013   2          result = 0;
1014   2        }
1015   1        ota_fw_info.mcu_current_offset = 0;
1016   1        zigbee_uart_write_frame(MCU_OTA_NOTIFY_CMD,length);
1017   1        
1018   1        if (1 == result)
1019   1        {
1020   2          mcu_ota_result_report(0x01); //0x01 is fail
1021   2        }
1022   1        else
1023   1        {
1024   2          //
1025   2        }
1026   1      }
1027          
1028          /**
1029          * @brief mcu ota data result notify
1030          * @param[in] {void} 
1031          * @return  void 
1032          */
1033          void mcu_ota_result_event(unsigned char offset)
1034          {
1035   1        unsigned char status = zigbee_uart_rx_buf[offset + DATA_START];
1036   1        
1037   1        if(status == 0x00){
1038   2          //ok
1039   2        }
C51 COMPILER V9.52.0.0   PROTOCOL                                                          01/18/2021 13:48:16 PAGE 18  

1040   1        else if(status == 0x01) {
1041   2          //error
1042   2          //go bootloader
1043   2        }
1044   1      }
1045          
1046          #endif


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1359    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     33    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----      33
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
